<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Guitar Scale Explorer</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    :root {
      color-scheme: dark;
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Inter', 'Segoe UI', sans-serif;
      background: #0a0a0f;
      color: #e8e8eb;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    body {
      margin: 0;
      padding: 2rem;
      min-height: 100vh;
      background: linear-gradient(135deg, #0a0a0f 0%, #14141f 100%);
    }
    h1 {
      margin: 0 0 1.5rem 0;
      font-size: 1.75rem;
      font-weight: 700;
      color: #ffffff;
      letter-spacing: -0.03em;
    }
    .header-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
    }
    .scale-selector {
      background: #1a1a27;
      border: 1px solid #2a2a3a;
      border-radius: 12px;
      padding: 1rem 1.25rem;
      margin-bottom: 1.5rem;
      display: flex;
      gap: 1.5rem;
      align-items: center;
      flex-wrap: wrap;
    }
    .scale-selector > div {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    .scale-selector select {
      padding: 0.5rem 0.75rem;
      border: 1px solid #2a2a3a;
      border-radius: 8px;
      font-size: 0.875rem;
      font-weight: 500;
      background: #14141f;
      color: #e8e8eb;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 180px;
    }
    .scale-selector select:hover {
      border-color: #3a3a4a;
      background: #1a1a27;
    }
    .scale-selector select:focus {
      outline: none;
      border-color: #4a9eff;
      box-shadow: 0 0 0 3px rgba(74, 158, 255, 0.1);
    }
    .custom-select-wrapper {
      position: relative;
      min-width: 180px;
    }
    .custom-select-button {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.5rem 0.75rem;
      border: 1px solid #2a2a3a;
      border-radius: 8px;
      font-size: 0.875rem;
      font-weight: 500;
      background: #14141f;
      color: #e8e8eb;
      cursor: pointer;
      transition: all 0.2s;
      user-select: none;
    }
    .custom-select-button:hover {
      border-color: #3a3a4a;
      background: #1a1a27;
    }
    .custom-select-button:focus {
      outline: none;
      border-color: #4a9eff;
      box-shadow: 0 0 0 3px rgba(74, 158, 255, 0.1);
    }
    .dropdown-arrow {
      font-size: 0.625rem;
      color: #8a8a9a;
      transition: transform 0.2s;
    }
    .custom-select-button[aria-expanded="true"] .dropdown-arrow {
      transform: rotate(180deg);
    }
    .custom-select-dropdown {
      position: absolute;
      top: calc(100% + 0.25rem);
      left: 0;
      right: 0;
      background: #14141f;
      border: 1px solid #2a2a3a;
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      max-height: 400px;
      overflow-y: auto;
      z-index: 1000;
    }
    .custom-select-dropdown::-webkit-scrollbar {
      width: 8px;
    }
    .custom-select-dropdown::-webkit-scrollbar-track {
      background: #0a0a0f;
      border-radius: 4px;
    }
    .custom-select-dropdown::-webkit-scrollbar-thumb {
      background: #2a2a3a;
      border-radius: 4px;
    }
    .custom-select-dropdown::-webkit-scrollbar-thumb:hover {
      background: #3a3a4a;
    }
    .category-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.625rem 0.75rem;
      font-size: 0.75rem;
      font-weight: 600;
      color: #8a8a9a;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: #1a1a27;
      cursor: pointer;
      user-select: none;
      border-bottom: 1px solid #2a2a3a;
    }
    .category-header:hover {
      background: #1f1f2c;
      color: #9a9aaa;
    }
    .category-header:first-child {
      border-top-left-radius: 7px;
      border-top-right-radius: 7px;
    }
    .category-icon {
      display: inline-block;
      font-size: 0.75rem;
      transition: transform 0.2s;
    }
    .category-header.collapsed .category-icon {
      transform: rotate(-90deg);
    }
    .category-items {
      display: block;
      border-bottom: 1px solid #2a2a3a;
    }
    .category-items.collapsed {
      display: none;
    }
    .scale-option {
      padding: 0.5rem 0.75rem 0.5rem 1.5rem;
      font-size: 0.875rem;
      color: #e8e8eb;
      cursor: pointer;
      transition: background 0.15s;
    }
    .scale-option:hover {
      background: #1f1f2c;
    }
    .scale-option.selected {
      background: #2a3a4a;
      color: #4a9eff;
      font-weight: 500;
    }
    .scale-selector label {
      font-size: 0.75rem;
      font-weight: 600;
      color: #8a8a9a;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    .fretboard-container {
      position: relative;
      background: #1a1a27;
      border: 1px solid #2a2a3a;
      border-radius: 12px;
      padding: 0;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }
    .fretboard-controls {
      display: flex;
      align-items: center;
      gap: 1.5rem;
      padding: 0.875rem 1.25rem;
      background: #14141f;
      border-bottom: 1px solid #2a2a3a;
      flex-wrap: wrap;
    }
    .control-section {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .control-label {
      font-size: 0.75rem;
      font-weight: 600;
      color: #8a8a9a;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      white-space: nowrap;
    }
    .control-btn {
      width: 34px;
      height: 34px;
      padding: 0;
      font-size: 15px;
      font-weight: 600;
      line-height: 1;
      border: 1px solid #2a2a3a;
      background: #1a1a27;
      color: #b8b8c8;
      border-radius: 7px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }
    .control-btn:hover {
      background: #24243a;
      border-color: #3a3a4a;
      color: #e8e8eb;
    }
    .control-btn.active {
      background: linear-gradient(135deg, #4a9eff 0%, #3b7dd6 100%);
      color: #ffffff;
      border-color: #4a9eff;
      box-shadow: 0 2px 8px rgba(74, 158, 255, 0.3);
    }
    .divider {
      width: 1px;
      height: 24px;
      background: #2a2a3a;
    }
    canvas {
      display: block;
      margin: 0 auto;
      padding: 1.5rem;
      background: #1a1a27;
      touch-action: none;
    }
    .info {
      padding: 0.75rem 1rem;
      font-size: 0.813rem;
      font-weight: 500;
      color: #8a8a9a;
      background: #14141f;
      border-top: 1px solid #2a2a3a;
      text-align: center;
    }
    footer {
      text-align: center;
      color: #8a8a9a;
      font-size: 0.813rem;
      padding: 2rem 0 1rem;
    }
  </style>
</head>
<body>
  <div class="header-row">
    <h1>üé∏ Guitar Scale Explorer</h1>
    <button id="themeToggle" class="control-btn" style="width: auto; padding: 0 1rem;" title="Toggle theme">
      <span id="themeIcon">‚òÄÔ∏è</span>
    </button>
  </div>

  <div class="scale-selector">
    <div>
      <label>Pattern</label>
      <div style="position: relative;">
        <input
          type="text"
          id="patternSearch"
          placeholder="Search patterns..."
          style="width: 100%; padding: 0.5rem 0.75rem 0.5rem 2rem; border: 1px solid #2a2a3a; border-radius: 8px; font-size: 0.875rem; background: #14141f; color: #e8e8eb; margin-bottom: 0.5rem;"
        />
        <span style="position: absolute; left: 0.6rem; top: 0.55rem; font-size: 0.875rem; color: #8a8a9a;">üîç</span>
      </div>
      <div class="custom-select-wrapper">
        <div id="scaleSelectButton" class="custom-select-button" tabindex="0" role="button" aria-haspopup="listbox" aria-expanded="false">
          <span id="scaleSelectValue">Select a pattern...</span>
          <span class="dropdown-arrow">‚ñº</span>
        </div>
        <div id="scaleSelectDropdown" class="custom-select-dropdown" role="listbox" style="display: none;"></div>
      </div>
    </div>

    <div style="display: flex; gap: 0.5rem; align-items: flex-end;">
      <div>
        <label>Root</label>
        <select id="rootSelect" style="width: 70px;"></select>
      </div>
      <button id="enharmonicToggle" class="control-btn" title="Showing sharps (click for flats)" style="height: 38px; padding: 0 0.75rem; margin-bottom: 0;">‚ôØ</button>
    </div>

    <div id="fingeringPatternContainer" style="display: none;">
      <label>Fingering Pattern</label>
      <select id="fingeringPatternSelect">
        <option value="all">All Tones</option>
      </select>
    </div>

    <div>
      <label>Instrument</label>
      <select id="instrumentSelect">
        <option value="guitar">Guitar</option>
        <option value="cello">Cello</option>
      </select>
    </div>

    <div style="display: flex; align-items: flex-end;">
      <button id="playButton" class="control-btn" style="width: auto; padding: 0 1rem; height: 38px;" title="Play scale">
        ‚ñ∂ Play
      </button>
    </div>

    <div>
      <label>Metronome</label>
      <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
        <button id="metronomeToggle" class="control-btn" style="width: auto; padding: 0 0.75rem; height: 38px;" title="Toggle metronome">
          Off
        </button>
        <select id="metronomeSound" style="padding: 0.5rem 0.75rem; border: 1px solid #2a2a3a; border-radius: 8px; font-size: 0.875rem; background: #14141f; color: #e8e8eb; min-width: 100px;">
          <option value="woodblock">Woodblock</option>
          <option value="click">Click</option>
          <option value="beep">Beep</option>
          <option value="cowbell">Cowbell</option>
        </select>
        <div style="display: flex; align-items: center; gap: 0.25rem;">
          <button id="metronomeBpmDown" class="control-btn" style="width: 28px; height: 38px; padding: 0; font-size: 16px;" title="Decrease BPM">‚àí</button>
          <input
            type="number"
            id="metronomeBpm"
            value="72"
            min="30"
            max="240"
            style="width: 50px; padding: 0.5rem 0.25rem; border: 1px solid #2a2a3a; border-radius: 8px; font-size: 0.875rem; background: #14141f; color: #e8e8eb; text-align: center;"
          />
          <button id="metronomeBpmUp" class="control-btn" style="width: 28px; height: 38px; padding: 0; font-size: 16px;" title="Increase BPM">+</button>
          <span style="font-size: 0.75rem; color: #8a8a9a;">BPM</span>
        </div>
      </div>
    </div>
  </div>

  <div class="fretboard-container">
    <div class="fretboard-controls">
      <!-- Fret Range -->
      <div class="control-section">
        <span class="control-label">Frets</span>
        <button class="control-btn" id="fretRangeMinus" title="Show fewer frets">‚àí</button>
        <span id="fretRangeDisplay" style="font-size: 0.813rem; color: #e8e8eb; min-width: 40px; text-align: center;">0-24</span>
        <button class="control-btn" id="fretRangePlus" title="Show more frets">+</button>
      </div>

      <div class="divider"></div>

      <!-- Hand Span -->
      <div class="control-section">
        <span class="control-label">Span</span>
        <button class="control-btn" data-span="4" title="4 frets">4</button>
        <button class="control-btn active" data-span="5" title="5 frets">5</button>
        <button class="control-btn" data-span="6" title="6 frets">6</button>
        <button class="control-btn" data-span="0" title="Show all notes">Off</button>
      </div>

      <div class="divider"></div>

      <!-- Display Options -->
      <div class="control-section">
        <span class="control-label">Show</span>
        <button class="control-btn active" id="toggleDisplay" title="Toggle between degrees and notes">#</button>
      </div>

      <div class="divider"></div>

      <!-- Zoom -->
      <div class="control-section">
        <span class="control-label">Zoom</span>
        <button class="control-btn" id="zoomOut" title="Zoom out">‚àí</button>
        <button class="control-btn" id="resetZoom" title="Reset zoom">‚äô</button>
        <button class="control-btn" id="zoomIn" title="Zoom in">+</button>
      </div>

      <div class="divider"></div>

      <!-- Marker Style -->
      <div class="control-section">
        <span class="control-label">Markers</span>
        <button class="control-btn active" data-markers="dots" title="Standard dots">‚óè</button>
        <button class="control-btn" data-markers="blocks" title="Gibson blocks">‚ñ¨</button>
        <button class="control-btn" data-markers="birds" title="PRS birds">üê¶</button>
        <button class="control-btn" data-markers="small" title="Fender dots">‚Ä¢</button>
        <button class="control-btn" data-markers="none" title="No markers">‚óã</button>
      </div>
    </div>

    <canvas id="fretboardCanvas" width="2400" height="300"></canvas>

    <div class="info" id="info">
      Drag the blue box to move your practice position
    </div>

    <div id="chordExplorerSection" style="display: none; padding: 1rem 1.25rem; background: #14141f; border-top: 1px solid #2a2a3a;">
      <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem;">
        <div style="font-size: 0.75rem; font-weight: 600; color: #8a8a9a; text-transform: uppercase; letter-spacing: 0.08em;">
          Chord Explorer
        </div>
        <button id="clearChordBtn" style="padding: 0.25rem 0.5rem; font-size: 0.75rem; background: #2a2a3a; color: #8a8a9a; border: 1px solid #3a3a4a; border-radius: 4px; cursor: pointer;">
          Show All Scale Tones
        </button>
      </div>
      <div style="margin-bottom: 0.5rem;">
        <div style="font-size: 0.688rem; color: #8a8a9a; margin-bottom: 0.375rem;">Triads:</div>
        <div id="chordsTriadsList" style="display: flex; flex-wrap: wrap; gap: 0.5rem;"></div>
      </div>
      <div>
        <div style="font-size: 0.688rem; color: #8a8a9a; margin-bottom: 0.375rem;">7th Chords:</div>
        <div id="chords7thList" style="display: flex; flex-wrap: wrap; gap: 0.5rem;"></div>
      </div>
    </div>

    <div id="progressionsSection" style="display: none; padding: 1rem 1.25rem; background: #14141f; border-top: 1px solid #2a2a3a;">
      <div style="font-size: 0.75rem; font-weight: 600; color: #8a8a9a; text-transform: uppercase; letter-spacing: 0.08em; margin-bottom: 0.75rem;">
        Practice Over
      </div>
      <div id="progressionsList" style="display: flex; flex-direction: column; gap: 0.5rem;"></div>
    </div>
  </div>

  <footer>
    Guitar Scale Explorer - Full Fretboard View - Deployed on GitHub Pages
  </footer>

  <script>
    console.log('Guitar Scale Explorer - Full Fretboard Edition');

    // Constants
    const STANDARD_TUNING = [4, 9, 2, 7, 11, 4]; // E A D G B E (in semitones from C)
    const NOTE_NAMES_SHARPS = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const NOTE_NAMES_FLATS = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
    const NOTE_NAMES = NOTE_NAMES_SHARPS; // Default to sharps for backwards compatibility
    const NOTE_TO_SEMITONE = {
      'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3,
      'E': 4, 'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8,
      'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
    };
    const PREFERRED_ROOTS_SHARPS = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const PREFERRED_ROOTS_FLATS = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
    const ALL_ROOTS = PREFERRED_ROOTS_SHARPS; // Default to sharps for backwards compatibility
    const ENHARMONIC_MAP = {
      'C#': 'Db', 'Db': 'C#',
      'D#': 'Eb', 'Eb': 'D#',
      'F#': 'Gb', 'Gb': 'F#',
      'G#': 'Ab', 'Ab': 'G#',
      'A#': 'Bb', 'Bb': 'A#'
    };

    // State
    const state = {
      scales: [],
      currentScale: null,
      currentScaleData: null,
      selectedScaleId: null,
      selectedFingeringPattern: 'all',
      selectedChord: null,
      diatonicChords: [],
      enharmonicPreference: 'sharps', // 'sharps' or 'flats' - default to sharps to match NOTE_NAMES
      categoriesCollapsed: JSON.parse(localStorage.getItem('categoriesCollapsed') || '{}'),
      dropdownOpen: false,
      fretMin: 0,
      fretMax: 24,
      practicePositionStart: 0,
      handSpan: 5,
      zoom: 1.0,
      showDegrees: true, // true = show degrees (#), false = show note names (‚ô™)
      isDragging: false,
      dragStartX: 0,
      dragStartFret: 0,
      theme: 'dark',
      markerStyle: 'dots',
      metronomeEnabled: false,
      metronomeBpm: 72,
      metronomeSound: 'woodblock'
    };

    // Theme colors
    const themes = {
      dark: {
        bodyBg: 'linear-gradient(135deg, #0a0a0f 0%, #14141f 100%)',
        cardBg: '#1a1a27',
        cardBorder: '#2a2a3a',
        controlBg: '#14141f',
        textPrimary: '#ffffff',
        textSecondary: '#e8e8eb',
        textMuted: '#8a8a9a',
        buttonBg: '#1a1a27',
        buttonBorder: '#2a2a3a',
        buttonText: '#b8b8c8',
        buttonHoverBg: '#24243a',
        buttonHoverBorder: '#3a3a4a',
        selectBg: '#14141f',
        selectBorder: '#2a2a3a',
        canvasBg: '#1a1a27',
        stringColor: '#3a3a4a',
        fretColor: '#2a2a3a',
        nutColor: '#4a4a5a',
        markerColor: '#2a2a3a',
        labelColor: '#6a6a7a',
        practiceBoxBg: 'rgba(74, 158, 255, 0.12)',
        practiceBoxBorder: '#4a9eff',
        noteColor: '#4a9eff',
        rootColor: '#fb923c',
        noteLabelColor: '#b8b8c8'
      },
      light: {
        bodyBg: 'linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%)',
        cardBg: '#ffffff',
        cardBorder: '#dee2e6',
        controlBg: '#f8f9fa',
        textPrimary: '#1a1a1a',
        textSecondary: '#343a40',
        textMuted: '#6c757d',
        buttonBg: '#ffffff',
        buttonBorder: '#dee2e6',
        buttonText: '#495057',
        buttonHoverBg: '#e9ecef',
        buttonHoverBorder: '#adb5bd',
        selectBg: '#ffffff',
        selectBorder: '#dee2e6',
        canvasBg: '#ffffff',
        stringColor: '#adb5bd',
        fretColor: '#ced4da',
        nutColor: '#8a8a9a',
        markerColor: '#e9ecef',
        labelColor: '#868e96',
        practiceBoxBg: 'rgba(74, 158, 255, 0.08)',
        practiceBoxBorder: '#4a9eff',
        noteColor: '#0d6efd',
        rootColor: '#fd7e14',
        noteLabelColor: '#495057'
      }
    };

    // DOM elements
    const canvas = document.getElementById('fretboardCanvas');
    const ctx = canvas.getContext('2d');
    const scaleSelectButton = document.getElementById('scaleSelectButton');
    const scaleSelectValue = document.getElementById('scaleSelectValue');
    const scaleSelectDropdown = document.getElementById('scaleSelectDropdown');
    const rootSelect = document.getElementById('rootSelect');
    const fingeringPatternSelect = document.getElementById('fingeringPatternSelect');
    const fingeringPatternContainer = document.getElementById('fingeringPatternContainer');

    // Audio setup
    let synth = null;
    let isPlaying = false;

    // Metronome setup
    let metronomeSynth = null;
    let metronomeLoop = null;

    function initMetronome(soundType = 'woodblock') {
      if (metronomeSynth) {
        metronomeSynth.dispose();
      }

      const soundConfigs = {
        woodblock: {
          synth: new Tone.MembraneSynth({
            pitchDecay: 0.05,
            octaves: 4,
            envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
          }),
          note: 'G5',
          duration: '32n',
          volume: -8
        },
        click: {
          synth: new Tone.MembraneSynth({
            pitchDecay: 0.008,
            octaves: 2,
            envelope: { attack: 0.0006, decay: 0.05, sustain: 0, release: 0.02 }
          }),
          note: 'C6',
          duration: '64n',
          volume: -5
        },
        beep: {
          synth: new Tone.Synth({
            oscillator: { type: 'sine' },
            envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.05 }
          }),
          note: 'C6',
          duration: '16n',
          volume: -10
        },
        cowbell: {
          synth: new Tone.MetalSynth({
            frequency: 800,
            envelope: { attack: 0.001, decay: 0.1, release: 0.05 },
            harmonicity: 5.1,
            modulationIndex: 32,
            resonance: 4000,
            octaves: 1.5
          }),
          note: 'C4',
          duration: '16n',
          volume: -12
        }
      };

      const config = soundConfigs[soundType] || soundConfigs.woodblock;
      metronomeSynth = config.synth.toDestination();
      metronomeSynth.volume.value = config.volume;

      // Store config for playback
      metronomeSynth._config = config;
    }

    function startMetronome() {
      if (metronomeLoop) {
        metronomeLoop.stop();
        metronomeLoop.dispose();
      }

      if (!metronomeSynth) {
        initMetronome(state.metronomeSound);
      }

      const bpm = state.metronomeBpm;
      Tone.Transport.bpm.value = bpm;

      const config = metronomeSynth._config;
      metronomeLoop = new Tone.Loop((time) => {
        metronomeSynth.triggerAttackRelease(config.note, config.duration, time);
      }, '4n');

      Tone.Transport.start();
      metronomeLoop.start(0);
    }

    function stopMetronome() {
      if (metronomeLoop) {
        metronomeLoop.stop();
        Tone.Transport.stop();
      }
    }

    // MIDI note numbers for open strings (standard tuning)
    const OPEN_STRING_MIDI = {
      6: 40,  // E2
      5: 45,  // A2
      4: 50,  // D3
      3: 55,  // G3
      2: 59,  // B3
      1: 64   // E4
    };

    /**
     * Initialize audio synthesizer with instrument sound
     */
    function initAudio(instrument = 'guitar') {
      if (synth) {
        synth.dispose();
      }

      if (instrument === 'guitar') {
        synth = new Tone.PolySynth(Tone.Synth, {
          oscillator: { type: 'triangle' },
          envelope: { attack: 0.005, decay: 0.3, sustain: 0.1, release: 1.2 }
        }).toDestination();
        synth.volume.value = -8;
      } else if (instrument === 'cello') {
        synth = new Tone.PolySynth(Tone.Synth, {
          oscillator: { type: 'sawtooth' },
          envelope: { attack: 0.05, decay: 0.3, sustain: 0.6, release: 1.5 }
        }).toDestination();
        synth.volume.value = -10;
      }
    }

    /**
     * Convert fretboard position to MIDI note number
     */
    function positionToMidi(string, fret) {
      return OPEN_STRING_MIDI[string] + fret;
    }

    /**
     * Convert MIDI note number to note name (e.g., 60 -> "C4")
     */
    function midiToNoteName(midiNote) {
      const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      const octave = Math.floor(midiNote / 12) - 1;
      const noteName = noteNames[midiNote % 12];
      return noteName + octave;
    }

    /**
     * Collect notes from current scale for playback
     */
    function collectScaleNotes() {
      if (!state.currentScaleData) return [];

      const root = state.currentScaleData.root;
      const intervals = (state.currentScaleData.properties?.intervals || state.currentScaleData.intervals || []).map(i => parseInt(i));
      const degrees = state.currentScaleData.properties?.scale_degrees || state.currentScaleData.scale_degrees || [];

      // Get all positions
      const allPositions = calculateFullFretboard(root, intervals, degrees);

      // Sort by pitch (MIDI note number)
      const sortedNotes = allPositions
        .map(pos => ({
          midi: positionToMidi(pos.string, pos.fret),
          string: pos.string,
          fret: pos.fret,
          note: pos.note,
          degree: pos.degree,
          isRoot: pos.isRoot
        }))
        .sort((a, b) => a.midi - b.midi);

      // Remove duplicates (same MIDI note) and limit to 9 notes
      const uniqueNotes = [];
      const seenMidi = new Set();

      for (const note of sortedNotes) {
        if (!seenMidi.has(note.midi)) {
          seenMidi.add(note.midi);
          uniqueNotes.push(note);
          if (uniqueNotes.length >= 9) break;
        }
      }

      return uniqueNotes;
    }

    /**
     * Play the scale or arpeggio
     */
    async function playScale() {
      if (isPlaying) return;

      const notes = collectScaleNotes();
      if (notes.length === 0) {
        console.log('No notes to play');
        return;
      }

      isPlaying = true;
      const playButton = document.getElementById('playButton');
      playButton.textContent = '‚è∏ Playing...';
      playButton.disabled = true;

      // Ensure audio context is started
      await Tone.start();

      if (!synth) {
        const instrument = document.getElementById('instrumentSelect').value;
        initAudio(instrument);
      }

      // Play notes sequentially
      const noteDuration = '8n';  // Eighth note
      const now = Tone.now();

      notes.forEach((note, index) => {
        const noteName = midiToNoteName(note.midi);
        const time = now + index * 0.3;  // 300ms between notes
        synth.triggerAttackRelease(noteName, noteDuration, time);
      });

      // Reset button after playing
      setTimeout(() => {
        isPlaying = false;
        playButton.textContent = '‚ñ∂ Play';
        playButton.disabled = false;
      }, notes.length * 300 + 500);
    }

    /**
     * Apply theme colors to UI
     */
    function applyTheme() {
      const theme = themes[state.theme];

      document.body.style.background = theme.bodyBg;

      document.querySelectorAll('.scale-selector').forEach(el => {
        el.style.background = theme.cardBg;
        el.style.borderColor = theme.cardBorder;
      });

      document.querySelectorAll('.scale-selector select').forEach(el => {
        el.style.background = theme.selectBg;
        el.style.borderColor = theme.selectBorder;
        el.style.color = theme.textSecondary;
      });

      document.querySelectorAll('.scale-selector label').forEach(el => {
        el.style.color = theme.textMuted;
      });

      document.querySelectorAll('.fretboard-container').forEach(el => {
        el.style.background = theme.cardBg;
        el.style.borderColor = theme.cardBorder;
      });

      document.querySelectorAll('.fretboard-controls').forEach(el => {
        el.style.background = theme.controlBg;
        el.style.borderColor = theme.cardBorder;
      });

      document.querySelectorAll('.control-label').forEach(el => {
        el.style.color = theme.textMuted;
      });

      document.querySelectorAll('.control-btn:not(.active)').forEach(el => {
        el.style.background = theme.buttonBg;
        el.style.borderColor = theme.buttonBorder;
        el.style.color = theme.buttonText;
      });

      document.querySelectorAll('.info').forEach(el => {
        el.style.background = theme.controlBg;
        el.style.borderColor = theme.cardBorder;
        el.style.color = theme.textMuted;
      });

      document.querySelector('h1').style.color = theme.textPrimary;
      document.querySelector('footer').style.color = theme.textMuted;
      document.getElementById('fretRangeDisplay').style.color = theme.textSecondary;

      // Metronome BPM input
      const bpmInput = document.getElementById('metronomeBpm');
      if (bpmInput) {
        bpmInput.style.background = theme.selectBg;
        bpmInput.style.borderColor = theme.selectBorder;
        bpmInput.style.color = theme.textSecondary;
      }

      // Pattern search input
      const patternSearch = document.getElementById('patternSearch');
      if (patternSearch) {
        patternSearch.style.background = theme.selectBg;
        patternSearch.style.borderColor = theme.selectBorder;
        patternSearch.style.color = theme.textSecondary;
      }

      document.getElementById('themeIcon').textContent = state.theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';

      drawFretboard();
    }

    /**
     * Calculate all positions of a scale across the entire fretboard
     */
    function calculateFullFretboard(root, scaleIntervals, scaleDegrees) {
      const rootSemitone = NOTE_TO_SEMITONE[root];
      const positions = [];

      for (let string = 6; string >= 1; string--) {
        const openStringSemitone = STANDARD_TUNING[6 - string];

        for (let fret = 0; fret <= 24; fret++) {
          const noteSemitone = (openStringSemitone + fret) % 12;
          const intervalFromRoot = (noteSemitone - rootSemitone + 12) % 12;

          const degreeIndex = scaleIntervals.indexOf(intervalFromRoot);
          if (degreeIndex !== -1) {
            const noteNames = state.enharmonicPreference === 'sharps' ? NOTE_NAMES_SHARPS : NOTE_NAMES_FLATS;
            const note = noteNames[noteSemitone];
            const degree = scaleDegrees[degreeIndex];
            const isRoot = note === root;

            positions.push({
              string: string,
              fret: fret,
              note: note,
              degree: degree,
              isRoot: isRoot,
              intervalFromRoot: intervalFromRoot
            });
          }
        }
      }

      return positions;
    }

    function calculateFingeringPatternPositions(scaleData, root, patternKey) {
      const fingeringVariations = scaleData.properties?.fingering_variations;
      if (!fingeringVariations || !fingeringVariations[patternKey]) {
        return [];
      }

      const pattern = fingeringVariations[patternKey];
      const frets = pattern.frets;
      const scaleIntervals = (scaleData.properties?.intervals || scaleData.intervals || []).map(i => parseInt(i));
      const scaleDegrees = scaleData.properties?.scale_degrees || scaleData.scale_degrees || scaleData.degrees || [];

      // Calculate transposition offset
      const originalRoot = scaleData.starting_tone || scaleData.root || 'A';
      const semitoneShift = (NOTE_TO_SEMITONE[root] - NOTE_TO_SEMITONE[originalRoot] + 12) % 12;

      const positions = [];
      const rootSemitone = NOTE_TO_SEMITONE[root];

      // Iterate through each string in the pattern
      Object.keys(frets).forEach(stringKey => {
        const stringNum = parseInt(stringKey);
        const stringFrets = frets[stringKey];

        stringFrets.forEach(fretStr => {
          const originalFret = parseInt(fretStr);
          const transposedFret = originalFret + semitoneShift;

          // Calculate the note at this position
          const openStringSemitone = STANDARD_TUNING[6 - stringNum];
          const noteSemitone = (openStringSemitone + transposedFret) % 12;
          const intervalFromRoot = (noteSemitone - rootSemitone + 12) % 12;

          // Find the degree for this interval
          const degreeIndex = scaleIntervals.indexOf(intervalFromRoot);
          if (degreeIndex !== -1) {
            const noteNames = state.enharmonicPreference === 'sharps' ? NOTE_NAMES_SHARPS : NOTE_NAMES_FLATS;
            const note = noteNames[noteSemitone];
            const degree = scaleDegrees[degreeIndex];
            const isRoot = note === root;

            positions.push({
              string: stringNum,
              fret: transposedFret,
              note: note,
              degree: degree,
              isRoot: isRoot,
              intervalFromRoot: intervalFromRoot
            });
          }
        });
      });

      return positions;
    }

    /**
     * Draw the fretboard
     */
    function drawFretboard() {
      if (!state.currentScaleData) return;

      const { fretMin, fretMax, zoom, showDegrees, theme } = state;
      const colors = themes[theme];

      const scaleData = state.currentScaleData;
      const root = scaleData.root;
      const intervals = (scaleData.properties?.intervals || scaleData.intervals || []).map(i => parseInt(i));
      const degrees = scaleData.properties?.scale_degrees || scaleData.scale_degrees || scaleData.degrees || [];

      // Use fingering pattern positions if a pattern is selected, otherwise show all tones
      let allPositions;
      if (state.selectedFingeringPattern !== 'all') {
        allPositions = calculateFingeringPatternPositions(scaleData, root, state.selectedFingeringPattern);
      } else {
        allPositions = calculateFullFretboard(root, intervals, degrees);
      }

      // Filter by chord tones if a chord is selected
      if (state.selectedChord) {
        const chordIntervals = state.selectedChord.type === 'seventh'
          ? state.selectedChord.intervalsWithSeventh
          : state.selectedChord.intervals;

        allPositions = allPositions.filter(pos => chordIntervals.includes(pos.intervalFromRoot));

        // Add chord tone labels (R, 3, 5, 7)
        allPositions.forEach(pos => {
          const chordToneIndex = chordIntervals.indexOf(pos.intervalFromRoot);
          const chordToneLabels = ['R', '3', '5', '7'];
          pos.chordTone = chordToneLabels[chordToneIndex];
          pos.isChordRoot = chordToneIndex === 0;
        });
      }

      const visiblePositions = allPositions.filter(p =>
        p.fret >= fretMin && p.fret <= fretMax
      );

      const width = canvas.width;
      const height = canvas.height;

      ctx.fillStyle = colors.canvasBg;
      ctx.fillRect(0, 0, width, height);

      if (visiblePositions.length === 0) {
        ctx.fillStyle = colors.textMuted;
        ctx.font = '20px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('No positions in this range', width / 2, height / 2);
        return;
      }

      const margin = 60;
      const stringSpacing = (height - 2 * margin) / 5;
      const fretCount = fretMax - fretMin;
      const fretSpacing = Math.min((width - 2 * margin) / fretCount, 80) * zoom;

      // Draw strings
      ctx.strokeStyle = colors.stringColor;
      ctx.lineWidth = 2;
      for (let i = 0; i < 6; i++) {
        const y = margin + i * stringSpacing;
        ctx.beginPath();
        ctx.moveTo(margin, y);
        ctx.lineTo(margin + fretCount * fretSpacing, y);
        ctx.stroke();

        const stringNum = i + 1;
        ctx.fillStyle = colors.textMuted;
        ctx.font = 'bold 13px sans-serif';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        ctx.fillText(`${stringNum}`, margin - 10, y);
      }

      // Draw frets
      for (let i = 0; i <= fretCount; i++) {
        const fretNumber = fretMin + i;
        const x = margin + i * fretSpacing;

        // Make the nut (between fret 0 and 1) more prominent
        if (fretNumber === 1 && fretMin === 0) {
          ctx.strokeStyle = colors.nutColor;
          ctx.lineWidth = 6;
        } else {
          ctx.strokeStyle = colors.fretColor;
          ctx.lineWidth = 2;
        }

        ctx.beginPath();
        ctx.moveTo(x, margin);
        ctx.lineTo(x, height - margin);
        ctx.stroke();

        if (i < fretCount) {
          if (fretCount > 12 && i % 2 !== 0) continue;
          ctx.fillStyle = colors.labelColor;
          ctx.font = 'bold 12px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          ctx.fillText(fretNumber, x + fretSpacing / 2, height - margin + 15);
        }
      }

      // Draw fret markers
      const markerFrets = [3, 5, 7, 9, 12, 15, 17, 19, 21, 24];
      const markerStyle = state.markerStyle;

      if (markerStyle !== 'none') {
        ctx.fillStyle = colors.markerColor;

        markerFrets.forEach(fret => {
          if (fret >= fretMin && fret <= fretMax) {
            const x = margin + (fret - fretMin - 0.5) * fretSpacing;
            const y = height / 2;
            const isDouble = fret === 12 || fret === 24;

            if (markerStyle === 'dots') {
              // Standard circular dots (7px radius)
              if (isDouble) {
                ctx.beginPath();
                ctx.arc(x, y - 30, 7, 0, 2 * Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x, y + 30, 7, 0, 2 * Math.PI);
                ctx.fill();
              } else {
                ctx.beginPath();
                ctx.arc(x, y, 7, 0, 2 * Math.PI);
                ctx.fill();
              }
            } else if (markerStyle === 'blocks') {
              // Gibson-style block inlays
              const blockWidth = Math.min(fretSpacing * 0.6, 40);
              const blockHeight = 16;
              if (isDouble) {
                ctx.fillRect(x - blockWidth / 2, y - 30 - blockHeight / 2, blockWidth, blockHeight);
                ctx.fillRect(x - blockWidth / 2, y + 30 - blockHeight / 2, blockWidth, blockHeight);
              } else {
                ctx.fillRect(x - blockWidth / 2, y - blockHeight / 2, blockWidth, blockHeight);
              }
            } else if (markerStyle === 'small') {
              // Fender-style small dots (5px radius)
              if (isDouble) {
                ctx.beginPath();
                ctx.arc(x, y - 30, 5, 0, 2 * Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x, y + 30, 5, 0, 2 * Math.PI);
                ctx.fill();
              } else {
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, 2 * Math.PI);
                ctx.fill();
              }
            } else if (markerStyle === 'birds') {
              // PRS-style bird inlays
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.font = '20px serif';
              ctx.fillStyle = colors.markerColor;

              if (isDouble) {
                ctx.fillText('üê¶', x, y - 30);
                ctx.fillText('üê¶', x, y + 30);
              } else {
                ctx.fillText('üê¶', x, y);
              }
            }
          }
        });
      }

      // Draw practice position box (only if span is not 0/Off)
      if (state.handSpan > 0) {
        const practiceStart = state.practicePositionStart;
        const practiceEnd = practiceStart + state.handSpan - 1;

        if (practiceStart >= fretMin && practiceStart <= fretMax) {
          const x1 = margin + (practiceStart - fretMin) * fretSpacing;
          const x2 = margin + (Math.min(practiceEnd, fretMax) - fretMin + 1) * fretSpacing;

          ctx.fillStyle = colors.practiceBoxBg;
          ctx.fillRect(x1, margin - 10, x2 - x1, height - 2 * margin + 20);

          ctx.strokeStyle = colors.practiceBoxBorder;
          ctx.lineWidth = 3;
          if (theme === 'dark') {
            ctx.shadowBlur = 8;
            ctx.shadowColor = 'rgba(74, 158, 255, 0.4)';
          }
          ctx.setLineDash([6, 4]);
          ctx.strokeRect(x1, margin - 10, x2 - x1, height - 2 * margin + 20);
          ctx.setLineDash([]);
          ctx.shadowBlur = 0;

          // Label
          const labelText = `Frets ${practiceStart}-${practiceEnd}`;
          const labelX = (x1 + x2) / 2;
          const labelY = height - margin + 35;

          ctx.font = 'bold 13px sans-serif';
          const textMetrics = ctx.measureText(labelText);
          const pillWidth = textMetrics.width + 16;
          const pillHeight = 24;

          ctx.fillStyle = colors.controlBg;
          ctx.beginPath();
          ctx.roundRect(labelX - pillWidth / 2, labelY - pillHeight / 2, pillWidth, pillHeight, 12);
          ctx.fill();

          ctx.strokeStyle = colors.practiceBoxBorder;
          ctx.lineWidth = 1.5;
          ctx.stroke();

          ctx.fillStyle = colors.practiceBoxBorder;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(labelText, labelX, labelY);
        }
      }

      // Draw notes
      visiblePositions.forEach(pos => {
        const stringIndex = pos.string - 1;
        const fretOffset = pos.fret - fretMin;
        const x = margin + (fretOffset + 0.5) * fretSpacing;
        const y = margin + stringIndex * stringSpacing;
        const radius = Math.min(fretSpacing * 0.35, 16);

        let opacity = 1.0;
        // Only dim notes if span is active (not 0/Off)
        if (state.handSpan > 0) {
          const practiceEnd = state.practicePositionStart + state.handSpan - 1;
          if (pos.fret < state.practicePositionStart || pos.fret > practiceEnd) {
            opacity = 0.2;
          }
        }

        ctx.globalAlpha = opacity;
        if (opacity === 1.0 && theme === 'dark') {
          ctx.shadowBlur = 10;
          ctx.shadowColor = pos.isRoot ? 'rgba(251, 146, 60, 0.5)' : 'rgba(74, 158, 255, 0.5)';
        }
        ctx.fillStyle = pos.isRoot ? colors.rootColor : colors.noteColor;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Draw label inside circle
        ctx.fillStyle = '#ffffff';
        ctx.font = `bold ${Math.min(radius * 0.8, 12)}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        let label = '';
        if (showDegrees) {
          // Show scale degrees/intervals
          label = pos.degree;
        } else {
          // Show note names
          label = pos.note;
        }

        ctx.fillText(label, x, y);

        ctx.globalAlpha = 1.0;
      });
    }

    /**
     * Load scale catalog
     */
    async function loadScaleCatalog() {
      const scaleFiles = [
        'aeolian_3nps', 'altered_dominant', 'arpeggio_2noteperstring_dominant7',
        'arpeggio_2notesperstring_m7b5', 'arpeggio_major_7_2_notes_per_string',
        'arpeggio_minor_7_2_notes_per_string', 'dorian_3nps',
        'half_whole_diminished', 'harmonic_minor_3nps', 'hexatonic_pos1',
        'ionian_3nps', 'jazz_blues_pos1', 'locrian_3nps', 'lydian_3nps',
        'major_blues_box', 'melodic_minor_3nps', 'minor_blues_box',
        'minor_pentatonic_box2', 'mixolydian_3nps', 'phrygian_3nps', 'whole_tone'
      ];

      const promises = scaleFiles.map(async (filename) => {
        try {
          const response = await fetch(`scales/${filename}.json`);
          const data = await response.json();
          return {
            id: filename,
            name: data.Item.scale_type || filename,
            category: data.Item.properties?.category || 'other',
            data: data.Item
          };
        } catch (err) {
          console.error(`Failed to load ${filename}:`, err);
          return null;
        }
      });

      state.scales = (await Promise.all(promises)).filter(s => s !== null);
      populateScaleSelect();
      populateRootSelect();

      if (state.scales.length > 0) {
        // Set initial selection
        state.selectedScaleId = state.scales[0].id;
        scaleSelectValue.textContent = state.scales[0].name;
        updateDisplay();
      }
    }

    function populateScaleSelect(filterText = '') {
      scaleSelectDropdown.innerHTML = '';

      const filter = filterText.toLowerCase().trim();

      // Group scales by category
      const categories = {
        'scales': { label: 'Scales', scales: [] },
        'modes': { label: 'Modes', scales: [] },
        'arpeggios': { label: 'Arpeggios', scales: [] }
      };

      state.scales.forEach(scale => {
        // Filter by search text
        if (filter && !scale.name.toLowerCase().includes(filter) && !scale.id.toLowerCase().includes(filter)) {
          return;
        }

        const category = scale.category || 'scales';
        if (categories[category]) {
          categories[category].scales.push(scale);
        }
      });

      let hasResults = false;

      // Create custom dropdown structure with collapsible categories
      ['scales', 'modes', 'arpeggios'].forEach(categoryKey => {
        const category = categories[categoryKey];
        if (category.scales.length > 0) {
          hasResults = true;

          // Sort scales alphabetically within category
          category.scales.sort((a, b) => a.name.localeCompare(b.name));

          // Determine if category should be collapsed
          const isCollapsed = state.categoriesCollapsed[categoryKey] === true;

          // Category header
          const header = document.createElement('div');
          header.className = `category-header${isCollapsed ? ' collapsed' : ''}`;
          header.dataset.category = categoryKey;
          header.innerHTML = `
            <div>
              <span class="category-icon">‚ñº</span>
              ${category.label} (${category.scales.length})
            </div>
          `;
          header.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleCategory(categoryKey);
          });

          scaleSelectDropdown.appendChild(header);

          // Category items container
          const itemsContainer = document.createElement('div');
          itemsContainer.className = `category-items${isCollapsed ? ' collapsed' : ''}`;
          itemsContainer.dataset.category = categoryKey;

          category.scales.forEach(scale => {
            const option = document.createElement('div');
            option.className = 'scale-option';
            if (scale.id === state.selectedScaleId) {
              option.classList.add('selected');
            }
            option.dataset.scaleId = scale.id;
            option.textContent = scale.name;
            option.addEventListener('click', (e) => {
              e.stopPropagation();
              selectScale(scale.id);
            });

            itemsContainer.appendChild(option);
          });

          scaleSelectDropdown.appendChild(itemsContainer);
        }
      });

      // Show "No results" message if nothing found
      if (!hasResults && filter) {
        const noResults = document.createElement('div');
        noResults.style.cssText = 'padding: 1rem; text-align: center; color: #8a8a9a; font-size: 0.875rem;';
        noResults.textContent = 'No patterns found';
        scaleSelectDropdown.appendChild(noResults);
      }
    }

    function toggleCategory(categoryKey) {
      const isCurrentlyCollapsed = state.categoriesCollapsed[categoryKey] === true;
      state.categoriesCollapsed[categoryKey] = !isCurrentlyCollapsed;

      // Save to localStorage
      localStorage.setItem('categoriesCollapsed', JSON.stringify(state.categoriesCollapsed));

      // Update UI
      const header = scaleSelectDropdown.querySelector(`.category-header[data-category="${categoryKey}"]`);
      const items = scaleSelectDropdown.querySelector(`.category-items[data-category="${categoryKey}"]`);

      if (header && items) {
        if (state.categoriesCollapsed[categoryKey]) {
          header.classList.add('collapsed');
          items.classList.add('collapsed');
        } else {
          header.classList.remove('collapsed');
          items.classList.remove('collapsed');
        }
      }
    }

    function selectScale(scaleId) {
      state.selectedScaleId = scaleId;

      // Reset fingering pattern and chord selection when switching scales
      state.selectedFingeringPattern = 'all';
      state.selectedChord = null;

      // Update button display
      const scale = state.scales.find(s => s.id === scaleId);
      if (scale) {
        scaleSelectValue.textContent = scale.name;
      }

      // Close dropdown
      closeDropdown();

      // Update the fretboard
      updateDisplay();
    }

    function openDropdown() {
      state.dropdownOpen = true;
      scaleSelectDropdown.style.display = 'block';
      scaleSelectButton.setAttribute('aria-expanded', 'true');
    }

    function closeDropdown() {
      state.dropdownOpen = false;
      scaleSelectDropdown.style.display = 'none';
      scaleSelectButton.setAttribute('aria-expanded', 'false');
    }

    function toggleDropdown() {
      if (state.dropdownOpen) {
        closeDropdown();
      } else {
        openDropdown();
      }
    }

    function populateRootSelect() {
      // IMPORTANT: Save current value BEFORE clearing the select
      const currentValue = rootSelect.value || 'A';
      const roots = state.enharmonicPreference === 'sharps' ? PREFERRED_ROOTS_SHARPS : PREFERRED_ROOTS_FLATS;

      rootSelect.innerHTML = '';

      roots.forEach(root => {
        const option = document.createElement('option');
        option.value = root;
        option.textContent = root;
        rootSelect.appendChild(option);
      });

      // Try to maintain the same pitch if switching enharmonics
      if (currentValue) {
        const currentSemitone = NOTE_TO_SEMITONE[currentValue];
        const matchingRoot = roots.find(r => NOTE_TO_SEMITONE[r] === currentSemitone);
        rootSelect.value = matchingRoot || roots[9]; // Default to A (index 9)
      } else {
        rootSelect.value = 'A';
      }
    }

    function populateFingeringPatternSelect() {
      // TEMPORARILY DISABLED - Issue #29
      // Need to properly define patterns with position shifts before enabling
      fingeringPatternContainer.style.display = 'none';
      state.selectedFingeringPattern = 'all';
      return;

      // const scale = state.scales.find(s => s.id === state.selectedScaleId);
      // if (!scale) return;

      // const fingeringVariations = scale.data.properties?.fingering_variations;

      // // Hide the selector if no fingering variations exist
      // if (!fingeringVariations || Object.keys(fingeringVariations).length === 0) {
      //   fingeringPatternContainer.style.display = 'none';
      //   state.selectedFingeringPattern = 'all';
      //   return;
      // }

      // // Show the selector
      // fingeringPatternContainer.style.display = 'flex';

      // // Populate options
      // fingeringPatternSelect.innerHTML = '';

      // // Always add "All Tones" option
      // const allOption = document.createElement('option');
      // allOption.value = 'all';
      // allOption.textContent = 'All Tones';
      // fingeringPatternSelect.appendChild(allOption);

      // // Add fingering variation options
      // Object.keys(fingeringVariations).forEach(key => {
      //   const variation = fingeringVariations[key];
      //   const option = document.createElement('option');
      //   option.value = key;
      //   option.textContent = variation.description || key;
      //   fingeringPatternSelect.appendChild(option);
      // });

      // // Set current selection
      // fingeringPatternSelect.value = state.selectedFingeringPattern;
    }

    function transposeScale(scaleData, targetRoot) {
      const originalRoot = scaleData.starting_tone || 'A';
      const semitoneShift = (NOTE_TO_SEMITONE[targetRoot] - NOTE_TO_SEMITONE[originalRoot] + 12) % 12;

      return {
        ...scaleData,
        root: targetRoot,
        starting_tone: targetRoot
      };
    }

    function populateChordExplorer() {
      const chordExplorerSection = document.getElementById('chordExplorerSection');
      const chordsTriadsList = document.getElementById('chordsTriadsList');
      const chords7thList = document.getElementById('chords7thList');

      if (state.diatonicChords.length === 0) {
        chordExplorerSection.style.display = 'none';
        return;
      }

      chordExplorerSection.style.display = 'block';

      // Clear existing chords
      chordsTriadsList.innerHTML = '';
      chords7thList.innerHTML = '';

      // Populate triads
      state.diatonicChords.forEach((chord, index) => {
        if (chord.triadSymbol) {
          const btn = document.createElement('button');
          btn.textContent = chord.triadSymbol;
          btn.dataset.chordIndex = index;
          btn.dataset.chordType = 'triad';
          btn.style.cssText = 'padding: 0.375rem 0.75rem; font-size: 0.813rem; background: #2a2a3a; color: #e8e8eb; border: 1px solid #3a3a4a; border-radius: 6px; cursor: pointer; transition: all 0.2s; font-weight: 500;';
          btn.addEventListener('click', () => selectChord(chord, 'triad'));
          btn.addEventListener('mouseenter', function() {
            if (!this.classList.contains('selected-chord')) {
              this.style.background = '#3a3a4a';
              this.style.borderColor = '#4a9eff';
            }
          });
          btn.addEventListener('mouseleave', function() {
            if (!this.classList.contains('selected-chord')) {
              this.style.background = '#2a2a3a';
              this.style.borderColor = '#3a3a4a';
            }
          });
          chordsTriadsList.appendChild(btn);
        }
      });

      // Populate 7th chords
      state.diatonicChords.forEach((chord, index) => {
        if (chord.seventhSymbol) {
          const btn = document.createElement('button');
          btn.textContent = chord.seventhSymbol;
          btn.dataset.chordIndex = index;
          btn.dataset.chordType = 'seventh';
          btn.style.cssText = 'padding: 0.375rem 0.75rem; font-size: 0.813rem; background: #2a2a3a; color: #e8e8eb; border: 1px solid #3a3a4a; border-radius: 6px; cursor: pointer; transition: all 0.2s; font-weight: 500;';
          btn.addEventListener('click', () => selectChord(chord, 'seventh'));
          btn.addEventListener('mouseenter', function() {
            if (!this.classList.contains('selected-chord')) {
              this.style.background = '#3a3a4a';
              this.style.borderColor = '#4a9eff';
            }
          });
          btn.addEventListener('mouseleave', function() {
            if (!this.classList.contains('selected-chord')) {
              this.style.background = '#2a2a3a';
              this.style.borderColor = '#3a3a4a';
            }
          });
          chords7thList.appendChild(btn);
        }
      });
    }

    function selectChord(chord, type) {
      state.selectedChord = { ...chord, type };

      // Update button styles
      document.querySelectorAll('#chordsTriadsList button, #chords7thList button').forEach(btn => {
        btn.classList.remove('selected-chord');
        btn.style.background = '#2a2a3a';
        btn.style.borderColor = '#3a3a4a';
        btn.style.color = '#e8e8eb';
      });

      // Highlight selected button
      const selectedButtons = document.querySelectorAll(`button[data-chord-index="${chord.degree - 1}"][data-chord-type="${type}"]`);
      selectedButtons.forEach(btn => {
        btn.classList.add('selected-chord');
        btn.style.background = '#4a9eff';
        btn.style.borderColor = '#4a9eff';
        btn.style.color = '#ffffff';
      });

      drawFretboard();
    }

    function clearChordSelection() {
      state.selectedChord = null;

      // Reset button styles
      document.querySelectorAll('#chordsTriadsList button, #chords7thList button').forEach(btn => {
        btn.classList.remove('selected-chord');
        btn.style.background = '#2a2a3a';
        btn.style.borderColor = '#3a3a4a';
        btn.style.color = '#e8e8eb';
      });

      drawFretboard();
    }

    function calculateDiatonicChords(root, intervals) {
      const rootSemitone = NOTE_TO_SEMITONE[root];
      const chords = [];

      // Roman numerals for chord degrees
      const majorRomanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII'];
      const minorRomanNumerals = ['i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii'];

      // Build a chord from each scale degree
      intervals.forEach((rootInterval, index) => {
        // Stack thirds to build chord (root, 3rd, 5th, 7th)
        const third = intervals[(index + 2) % intervals.length];
        const fifth = intervals[(index + 4) % intervals.length];
        const seventh = intervals[(index + 6) % intervals.length];

        // Calculate interval sizes
        const thirdSize = (third - rootInterval + 12) % 12;
        const fifthSize = (fifth - rootInterval + 12) % 12;
        const seventhSize = (seventh - rootInterval + 12) % 12;

        // Determine chord quality
        const isMajorThird = thirdSize === 4;
        const isMinorThird = thirdSize === 3;
        const isPerfectFifth = fifthSize === 7;
        const isDiminishedFifth = fifthSize === 6;
        const isAugmentedFifth = fifthSize === 8;
        const isMajorSeventh = seventhSize === 11;
        const isMinorSeventh = seventhSize === 10;

        // Calculate the chord root note
        const chordRootSemitone = (rootSemitone + rootInterval) % 12;
        const noteNames = state.enharmonicPreference === 'sharps' ? NOTE_NAMES_SHARPS : NOTE_NAMES_FLATS;
        const chordRoot = noteNames[chordRootSemitone];

        // Determine chord symbol and quality
        let triadSymbol = '';
        let seventhSymbol = '';
        let romanNumeral = '';

        // Triad quality
        if (isMajorThird && isPerfectFifth) {
          triadSymbol = chordRoot;
          romanNumeral = majorRomanNumerals[index];
        } else if (isMinorThird && isPerfectFifth) {
          triadSymbol = chordRoot + 'm';
          romanNumeral = minorRomanNumerals[index];
        } else if (isMinorThird && isDiminishedFifth) {
          triadSymbol = chordRoot + 'dim';
          romanNumeral = minorRomanNumerals[index] + '¬∞';
        } else if (isMajorThird && isAugmentedFifth) {
          triadSymbol = chordRoot + 'aug';
          romanNumeral = majorRomanNumerals[index] + '+';
        }

        // 7th chord quality
        if (isMajorThird && isPerfectFifth && isMajorSeventh) {
          seventhSymbol = chordRoot + 'maj7';
        } else if (isMinorThird && isPerfectFifth && isMinorSeventh) {
          seventhSymbol = chordRoot + 'm7';
        } else if (isMajorThird && isPerfectFifth && isMinorSeventh) {
          seventhSymbol = chordRoot + '7';
        } else if (isMinorThird && isDiminishedFifth && isMinorSeventh) {
          seventhSymbol = chordRoot + 'm7b5';
        } else if (isMinorThird && isDiminishedFifth && (seventhSize === 9)) {
          seventhSymbol = chordRoot + 'dim7';
        } else if (isMinorThird && isPerfectFifth && isMajorSeventh) {
          seventhSymbol = chordRoot + 'mMaj7';
        } else if (isMajorThird && isAugmentedFifth && isMajorSeventh) {
          seventhSymbol = chordRoot + 'maj7#5';
        }

        chords.push({
          root: chordRoot,
          triadSymbol: triadSymbol,
          seventhSymbol: seventhSymbol,
          romanNumeral: romanNumeral,
          intervals: [rootInterval, third, fifth],
          intervalsWithSeventh: [rootInterval, third, fifth, seventh],
          degree: index + 1
        });
      });

      return chords;
    }

    function updateDisplay() {
      const scale = state.scales.find(s => s.id === state.selectedScaleId);
      if (!scale) return;

      const root = rootSelect.value;
      const transposed = transposeScale(scale.data, root);

      state.currentScaleData = transposed;
      state.currentScale = scale;

      // Update fingering pattern selector
      populateFingeringPatternSelect();

      document.getElementById('info').textContent =
        `${scale.name} in ${root} - Drag the blue box to move your practice position`;

      // Display chord progressions if available
      const progressions = scale.data.properties?.progressions || [];
      const progressionsSection = document.getElementById('progressionsSection');
      const progressionsList = document.getElementById('progressionsList');

      if (progressions.length > 0) {
        progressionsList.innerHTML = '';
        progressions.forEach(prog => {
          const progItem = document.createElement('div');
          progItem.style.cssText = 'display: flex; flex-direction: column; gap: 0.25rem; padding: 0.75rem; background: #1a1a27; border-radius: 8px; border: 1px solid #2a2a3a;';

          const progHeader = document.createElement('div');
          progHeader.style.cssText = 'display: flex; align-items: center; gap: 0.5rem;';

          const progIcon = document.createElement('span');
          progIcon.textContent = 'üéµ';
          progIcon.style.fontSize = '1rem';

          const progName = document.createElement('span');
          progName.textContent = prog.name;
          progName.style.cssText = 'font-size: 0.875rem; font-weight: 600; color: #e8e8eb;';

          progHeader.appendChild(progIcon);
          progHeader.appendChild(progName);

          const progChords = document.createElement('div');
          progChords.textContent = prog.progression;
          progChords.style.cssText = 'font-size: 0.813rem; color: #4a9eff; font-family: monospace; margin-left: 1.5rem;';

          const progDesc = document.createElement('div');
          progDesc.textContent = prog.description;
          progDesc.style.cssText = 'font-size: 0.75rem; color: #8a8a9a; margin-left: 1.5rem;';

          progItem.appendChild(progHeader);
          progItem.appendChild(progChords);
          progItem.appendChild(progDesc);
          progressionsList.appendChild(progItem);
        });
        progressionsSection.style.display = 'block';
      } else {
        progressionsSection.style.display = 'none';
      }

      // Calculate and display diatonic chords
      const intervals = (transposed.properties?.intervals || transposed.intervals || []).map(i => parseInt(i));
      if (intervals.length >= 7) {
        state.diatonicChords = calculateDiatonicChords(root, intervals);
        populateChordExplorer();
      } else {
        // Hide chord explorer for scales with less than 7 notes
        document.getElementById('chordExplorerSection').style.display = 'none';
        state.selectedChord = null;
      }

      drawFretboard();
    }

    // Event listeners
    rootSelect.addEventListener('change', updateDisplay);

    fingeringPatternSelect.addEventListener('change', (e) => {
      state.selectedFingeringPattern = e.target.value;
      drawFretboard();
    });

    // Chord explorer event listeners
    document.getElementById('clearChordBtn').addEventListener('click', clearChordSelection);

    // Custom dropdown event listeners
    scaleSelectButton.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleDropdown();
    });

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (state.dropdownOpen && !scaleSelectButton.contains(e.target) && !scaleSelectDropdown.contains(e.target)) {
        closeDropdown();
      }
    });

    // Keyboard navigation for dropdown button
    scaleSelectButton.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        toggleDropdown();
      } else if (e.key === 'Escape') {
        closeDropdown();
      }
    });

    // Pattern search filter
    document.getElementById('patternSearch').addEventListener('input', (e) => {
      populateScaleSelect(e.target.value);

      // Auto-open dropdown when typing
      if (e.target.value && !state.dropdownOpen) {
        openDropdown();
      }
    });

    document.getElementById('playButton').addEventListener('click', playScale);

    document.getElementById('instrumentSelect').addEventListener('change', (e) => {
      initAudio(e.target.value);
    });

    // Metronome event listeners
    document.getElementById('metronomeToggle').addEventListener('click', async () => {
      await Tone.start();

      state.metronomeEnabled = !state.metronomeEnabled;
      const toggleBtn = document.getElementById('metronomeToggle');

      if (state.metronomeEnabled) {
        startMetronome();
        toggleBtn.textContent = 'On';
        toggleBtn.classList.add('active');
      } else {
        stopMetronome();
        toggleBtn.textContent = 'Off';
        toggleBtn.classList.remove('active');
      }
    });

    document.getElementById('metronomeBpm').addEventListener('change', (e) => {
      const newBpm = parseInt(e.target.value);
      if (newBpm >= 30 && newBpm <= 240) {
        state.metronomeBpm = newBpm;
        if (state.metronomeEnabled) {
          Tone.Transport.bpm.value = newBpm;
        }
      }
    });

    document.getElementById('metronomeSound').addEventListener('change', (e) => {
      state.metronomeSound = e.target.value;
      const wasEnabled = state.metronomeEnabled;

      if (wasEnabled) {
        stopMetronome();
      }

      initMetronome(state.metronomeSound);

      if (wasEnabled) {
        startMetronome();
      }
    });

    document.getElementById('metronomeBpmUp').addEventListener('click', () => {
      const currentBpm = state.metronomeBpm;
      const newBpm = Math.min(240, currentBpm + 1);
      state.metronomeBpm = newBpm;
      document.getElementById('metronomeBpm').value = newBpm;
      if (state.metronomeEnabled) {
        Tone.Transport.bpm.value = newBpm;
      }
    });

    document.getElementById('metronomeBpmDown').addEventListener('click', () => {
      const currentBpm = state.metronomeBpm;
      const newBpm = Math.max(30, currentBpm - 1);
      state.metronomeBpm = newBpm;
      document.getElementById('metronomeBpm').value = newBpm;
      if (state.metronomeEnabled) {
        Tone.Transport.bpm.value = newBpm;
      }
    });

    document.getElementById('fretRangeMinus').addEventListener('click', () => {
      state.fretMax = Math.max(5, state.fretMax - 6);
      document.getElementById('fretRangeDisplay').textContent = `${state.fretMin}-${state.fretMax}`;
      drawFretboard();
    });

    document.getElementById('fretRangePlus').addEventListener('click', () => {
      state.fretMax = Math.min(24, state.fretMax + 6);
      document.getElementById('fretRangeDisplay').textContent = `${state.fretMin}-${state.fretMax}`;
      drawFretboard();
    });

    document.querySelectorAll('[data-span]').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('[data-span]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        state.handSpan = parseInt(btn.dataset.span);
        drawFretboard();
      });
    });

    document.getElementById('toggleDisplay').addEventListener('click', (e) => {
      state.showDegrees = !state.showDegrees;
      e.currentTarget.textContent = state.showDegrees ? '#' : '‚ô™';
      e.currentTarget.title = state.showDegrees ? 'Showing degrees (click for notes)' : 'Showing notes (click for degrees)';
      drawFretboard();
    });

    document.getElementById('enharmonicToggle').addEventListener('click', (e) => {
      state.enharmonicPreference = state.enharmonicPreference === 'sharps' ? 'flats' : 'sharps';
      // Update button to show current preference
      e.currentTarget.textContent = state.enharmonicPreference === 'sharps' ? '‚ôØ' : '‚ô≠';
      e.currentTarget.title = state.enharmonicPreference === 'sharps' ? 'Showing sharps (click for flats)' : 'Showing flats (click for sharps)';
      populateRootSelect();
      updateDisplay(); // Recalculate scale with new enharmonic preference
    });

    document.getElementById('zoomIn').addEventListener('click', () => {
      state.zoom = Math.min(state.zoom * 1.2, 3.0);
      drawFretboard();
    });

    document.getElementById('zoomOut').addEventListener('click', () => {
      state.zoom = Math.max(state.zoom / 1.2, 0.5);
      drawFretboard();
    });

    document.getElementById('resetZoom').addEventListener('click', () => {
      state.zoom = 1.0;
      drawFretboard();
    });

    document.querySelectorAll('[data-markers]').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('[data-markers]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        state.markerStyle = btn.dataset.markers;
        drawFretboard();
      });
    });

    document.getElementById('themeToggle').addEventListener('click', () => {
      state.theme = state.theme === 'dark' ? 'light' : 'dark';
      applyTheme();
    });

    // Canvas drag functionality
    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      const margin = 60;
      const width = canvas.width;
      const height = canvas.height;
      const fretCount = state.fretMax - state.fretMin;
      const fretSpacing = (width - 2 * margin) / fretCount;

      const practiceStart = state.practicePositionStart;
      const practiceEnd = practiceStart + state.handSpan - 1;

      if (practiceStart >= state.fretMin && practiceStart <= state.fretMax) {
        const x1 = margin + (practiceStart - state.fretMin) * fretSpacing;
        const x2 = margin + (Math.min(practiceEnd, state.fretMax) - state.fretMin + 1) * fretSpacing;

        if (mouseX >= x1 && mouseX <= x2 && mouseY >= margin - 10 && mouseY <= height - margin + 10) {
          state.isDragging = true;
          state.dragStartX = mouseX;
          state.dragStartFret = state.practicePositionStart;
          canvas.style.cursor = 'grabbing';
          e.preventDefault();
        }
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      const margin = 60;
      const width = canvas.width;
      const height = canvas.height;
      const fretCount = state.fretMax - state.fretMin;
      const fretSpacing = (width - 2 * margin) / fretCount;

      if (state.isDragging) {
        const deltaX = mouseX - state.dragStartX;
        const fretsDelta = Math.round(deltaX / fretSpacing);
        const newFret = Math.max(0, Math.min(24 - state.handSpan, state.dragStartFret + fretsDelta));

        if (newFret !== state.practicePositionStart) {
          state.practicePositionStart = newFret;
          drawFretboard();
        }
      } else {
        const practiceStart = state.practicePositionStart;
        const practiceEnd = practiceStart + state.handSpan - 1;

        if (practiceStart >= state.fretMin && practiceStart <= state.fretMax) {
          const x1 = margin + (practiceStart - state.fretMin) * fretSpacing;
          const x2 = margin + (Math.min(practiceEnd, state.fretMax) - state.fretMin + 1) * fretSpacing;

          if (mouseX >= x1 && mouseX <= x2 && mouseY >= margin - 10 && mouseY <= height - margin + 10) {
            canvas.style.cursor = 'grab';
          } else {
            canvas.style.cursor = 'default';
          }
        } else {
          canvas.style.cursor = 'default';
        }
      }
    });

    canvas.addEventListener('mouseup', () => {
      if (state.isDragging) {
        state.isDragging = false;
        canvas.style.cursor = 'grab';
      }
    });

    canvas.addEventListener('mouseleave', () => {
      if (state.isDragging) {
        state.isDragging = false;
        canvas.style.cursor = 'default';
      }
    });

    // Touch support for iOS/Android mobile
    canvas.addEventListener('touchstart', (e) => {
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];

      // Convert from display coordinates to canvas coordinates
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const touchX = (touch.clientX - rect.left) * scaleX;
      const touchY = (touch.clientY - rect.top) * scaleY;

      const margin = 60;
      const width = canvas.width;
      const height = canvas.height;
      const fretCount = state.fretMax - state.fretMin;
      const fretSpacing = (width - 2 * margin) / fretCount;

      const practiceStart = state.practicePositionStart;
      const practiceEnd = practiceStart + state.handSpan - 1;

      if (practiceStart >= state.fretMin && practiceStart <= state.fretMax) {
        const x1 = margin + (practiceStart - state.fretMin) * fretSpacing;
        const x2 = margin + (Math.min(practiceEnd, state.fretMax) - state.fretMin + 1) * fretSpacing;

        // More generous vertical hit area for touch (¬±30px in canvas space)
        if (touchX >= x1 && touchX <= x2 && touchY >= margin - 30 && touchY <= height - margin + 30) {
          state.isDragging = true;
          state.dragStartX = touchX;
          state.dragStartFret = state.practicePositionStart;
          e.preventDefault();
        }
      }
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      if (!state.isDragging) return;

      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];

      // Convert from display coordinates to canvas coordinates
      const scaleX = canvas.width / rect.width;
      const touchX = (touch.clientX - rect.left) * scaleX;

      const margin = 60;
      const width = canvas.width;
      const fretCount = state.fretMax - state.fretMin;
      const fretSpacing = (width - 2 * margin) / fretCount;

      const deltaX = touchX - state.dragStartX;
      const fretsDelta = Math.round(deltaX / fretSpacing);
      const newFret = Math.max(0, Math.min(24 - state.handSpan, state.dragStartFret + fretsDelta));

      if (newFret !== state.practicePositionStart) {
        state.practicePositionStart = newFret;
        drawFretboard();
      }

      e.preventDefault();
    }, { passive: false });

    canvas.addEventListener('touchend', () => {
      if (state.isDragging) {
        state.isDragging = false;
      }
    });

    canvas.addEventListener('touchcancel', () => {
      if (state.isDragging) {
        state.isDragging = false;
      }
    });

    // Initialize
    loadScaleCatalog().then(() => {
      applyTheme();
    });
  </script>
</body>
</html>
