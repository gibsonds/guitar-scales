<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Guitar Scale Explorer</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    :root {
      color-scheme: dark;
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Inter', 'Segoe UI', sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;

      /* CSS Custom Properties - Dark Theme (default) */
      --body-bg: linear-gradient(135deg, #0a0a0f 0%, #14141f 100%);
      --card-bg: #1a1a27;
      --card-border: #2a2a3a;
      --control-bg: #14141f;
      --text-primary: #ffffff;
      --text-secondary: #e8e8eb;
      --text-muted: #8a8a9a;
      --button-bg: #1a1a27;
      --button-border: #2a2a3a;
      --button-text: #b8b8c8;
      --button-hover-bg: #24243a;
      --button-hover-border: #3a3a4a;
      --select-bg: #14141f;
      --select-border: #2a2a3a;
      --canvas-bg: #1a1a27;
      --dropdown-bg: #14141f;
      --dropdown-border: #2a2a3a;
      --category-bg: #1a1a27;
      --category-hover-bg: #1f1f2c;
      --option-hover-bg: #1f1f2c;
      --option-selected-bg: #2a3a4a;

      background: var(--body-bg);
      color: var(--text-secondary);
    }

    [data-theme="light"] {
      color-scheme: light;

      /* CSS Custom Properties - Light Theme */
      --body-bg: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      --card-bg: #ffffff;
      --card-border: #dee2e6;
      --control-bg: #f8f9fa;
      --text-primary: #1a1a1a;
      --text-secondary: #343a40;
      --text-muted: #6c757d;
      --button-bg: #ffffff;
      --button-border: #dee2e6;
      --button-text: #495057;
      --button-hover-bg: #e9ecef;
      --button-hover-border: #adb5bd;
      --select-bg: #ffffff;
      --select-border: #dee2e6;
      --canvas-bg: #ffffff;
      --dropdown-bg: #ffffff;
      --dropdown-border: #dee2e6;
      --category-bg: #f8f9fa;
      --category-hover-bg: #e9ecef;
      --option-hover-bg: #e9ecef;
      --option-selected-bg: #d7e3f5;

      background: var(--body-bg);
      color: var(--text-secondary);
    }
    body {
      margin: 0;
      padding: 2rem;
      min-height: 100vh;
      background: var(--body-bg);
    }
    h1 {
      margin: 0 0 1.5rem 0;
      font-size: 1.75rem;
      font-weight: 700;
      color: var(--text-primary);
      letter-spacing: -0.03em;
    }
    .header-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
    }
    .scale-selector {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 12px;
      padding: 1rem 1.25rem;
      margin-bottom: 1.5rem;
      display: flex;
      gap: 1.5rem;
      align-items: center;
      flex-wrap: wrap;
    }
    .scale-selector > div {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }
    .scale-selector select {
      padding: 0.5rem 0.75rem;
      border: 1px solid #2a2a3a;
      border-radius: 8px;
      font-size: 0.875rem;
      font-weight: 500;
      background: #14141f;
      color: #e8e8eb;
      cursor: pointer;
      transition: all 0.2s;
      min-width: 180px;
    }
    .scale-selector select:hover {
      border-color: #3a3a4a;
      background: #1a1a27;
    }
    .scale-selector select:focus {
      outline: none;
      border-color: #4a9eff;
      box-shadow: 0 0 0 3px rgba(74, 158, 255, 0.1);
    }
    .custom-select-wrapper {
      position: relative;
      min-width: 360px;
    }
    .custom-select-button {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.5rem 0.75rem;
      border: 1px solid var(--select-border);
      border-radius: 8px;
      font-size: 0.875rem;
      font-weight: 500;
      background: var(--select-bg);
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.2s;
      user-select: none;
    }
    .custom-select-button:hover {
      border-color: var(--button-hover-border);
      background: var(--button-hover-bg);
    }
    .custom-select-button:focus {
      outline: none;
      border-color: #4a9eff;
      box-shadow: 0 0 0 3px rgba(74, 158, 255, 0.1);
    }
    .dropdown-arrow {
      font-size: 0.625rem;
      color: var(--text-muted);
      transition: transform 0.2s;
    }
    .custom-select-button[aria-expanded="true"] .dropdown-arrow {
      transform: rotate(180deg);
    }
    .custom-select-dropdown {
      position: absolute;
      top: calc(100% + 0.25rem);
      left: 0;
      right: 0;
      background: var(--dropdown-bg);
      border: 1px solid var(--dropdown-border);
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
      max-height: 700px;
      overflow-y: auto;
      z-index: 1000;
    }
    .custom-select-dropdown::-webkit-scrollbar {
      width: 8px;
    }
    .custom-select-dropdown::-webkit-scrollbar-track {
      background: var(--control-bg);
      border-radius: 4px;
    }
    .custom-select-dropdown::-webkit-scrollbar-thumb {
      background: var(--card-border);
      border-radius: 4px;
    }
    .custom-select-dropdown::-webkit-scrollbar-thumb:hover {
      background: var(--button-hover-border);
    }
    .category-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.625rem 0.75rem;
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: var(--category-bg);
      cursor: pointer;
      user-select: none;
      border-bottom: 1px solid var(--card-border);
    }
    .category-header:hover {
      background: var(--category-hover-bg);
      color: var(--text-muted);
    }
    .category-header:first-child {
      border-top-left-radius: 7px;
      border-top-right-radius: 7px;
    }
    .category-icon {
      display: inline-block;
      font-size: 0.75rem;
      transition: transform 0.2s;
    }
    .category-header.collapsed .category-icon {
      transform: rotate(-90deg);
    }
    .category-items {
      display: block;
      border-bottom: 1px solid var(--card-border);
    }
    .category-items.collapsed {
      display: none;
    }
    .scale-option {
      padding: 0.5rem 0.75rem 0.5rem 1.5rem;
      font-size: 0.875rem;
      color: var(--text-secondary);
      cursor: pointer;
      transition: background 0.15s;
    }
    .scale-option:hover {
      background: var(--option-hover-bg);
    }
    .scale-option.selected {
      background: var(--option-selected-bg);
      color: #4a9eff;
      font-weight: 500;
    }
    .scale-selector label {
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    .fretboard-container {
      position: relative;
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 12px;
      padding: 0;
      overflow: hidden;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }
    .fretboard-controls {
      display: flex;
      align-items: center;
      gap: 1.5rem;
      padding: 0.875rem 1.25rem;
      background: var(--control-bg);
      border-bottom: 1px solid var(--card-border);
      flex-wrap: wrap;
    }
    .control-section {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .control-label {
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      white-space: nowrap;
    }
    .control-btn {
      width: 34px;
      height: 34px;
      padding: 0;
      font-size: 15px;
      font-weight: 600;
      line-height: 1;
      border: 1px solid var(--button-border);
      background: var(--button-bg);
      color: var(--button-text);
      border-radius: 7px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }
    .control-btn:hover {
      background: var(--button-hover-bg);
      border-color: var(--button-hover-border);
      color: var(--text-secondary);
    }
    .control-btn.active {
      background: linear-gradient(135deg, #4a9eff 0%, #3b7dd6 100%);
      color: #ffffff;
      border-color: #4a9eff;
      box-shadow: 0 2px 8px rgba(74, 158, 255, 0.3);
    }
    .divider {
      width: 1px;
      height: 24px;
      background: #2a2a3a;
    }
    canvas {
      display: block;
      margin: 0 auto;
      padding: 1.5rem;
      touch-action: none;
    }
    .info {
      padding: 0.75rem 1rem;
      font-size: 0.813rem;
      font-weight: 500;
      color: var(--text-muted);
      background: var(--control-bg);
      border-top: 1px solid var(--card-border);
      text-align: center;
    }
    footer {
      text-align: center;
      color: var(--text-muted);
      font-size: 0.813rem;
      padding: 2rem 0 1rem;
    }
  </style>
</head>
<body>
  <div class="header-row">
    <h1>üé∏ Guitar Scale Explorer</h1>
    <div style="display: flex; gap: 0.5rem;">
      <button id="viewModeToggle" class="control-btn" style="width: auto; padding: 0 1rem;" title="Toggle view mode">
        <span id="viewModeIcon">üéº</span>
      </button>
      <button id="themeToggle" class="control-btn" style="width: auto; padding: 0 1rem;" title="Toggle theme">
        <span id="themeIcon">‚òÄÔ∏è</span>
      </button>
    </div>
  </div>

  <div class="scale-selector">
    <div style="display: flex; flex-direction: column; gap: 0.25rem;">
      <label style="text-transform: uppercase; font-size: 0.75rem; font-weight: 600; color: #8a8a9a; letter-spacing: 0.08em;">Pattern</label>
      <div style="position: relative;">
        <input
          type="text"
          id="patternSearch"
          placeholder="Search patterns..."
          style="width: 100%; padding: 0.5rem 0.75rem 0.5rem 2rem; border: 1px solid #2a2a3a; border-radius: 8px; font-size: 0.875rem; background: #14141f; color: #e8e8eb; margin-bottom: 0.5rem;"
        />
        <span style="position: absolute; left: 0.6rem; top: 0.55rem; font-size: 0.875rem; color: #8a8a9a;">üîç</span>
      </div>
      <div class="custom-select-wrapper">
        <div id="scaleSelectButton" class="custom-select-button" tabindex="0" role="button" aria-haspopup="listbox" aria-expanded="false">
          <span id="scaleSelectValue">Select a pattern...</span>
          <span class="dropdown-arrow">‚ñº</span>
        </div>
        <div id="scaleSelectDropdown" class="custom-select-dropdown" role="listbox" style="display: none;"></div>
      </div>
    </div>

    <div style="display: flex; flex-direction: column; gap: 0.25rem;">
      <label style="text-transform: uppercase; font-size: 0.75rem; font-weight: 600; color: #8a8a9a; letter-spacing: 0.08em;">Root</label>
      <div style="display: flex; gap: 0.5rem; align-items: center;">
        <select id="rootSelect" style="width: 60px !important; min-width: 60px !important; padding: 0.5rem 0.5rem; border: 1px solid #2a2a3a; border-radius: 8px; font-size: 0.875rem; font-weight: 500; background: #14141f; color: #e8e8eb; cursor: pointer; transition: all 0.2s; height: 38px;"></select>
        <button id="enharmonicToggle" class="control-btn" title="Showing sharps (click for flats)" style="height: 38px; width: 38px; padding: 0;">‚ôØ</button>
      </div>
    </div>

    <div id="fingeringPatternContainer" style="display: none; flex-direction: column; gap: 0.25rem;">
      <label style="text-transform: uppercase; font-size: 0.75rem; font-weight: 600; color: #8a8a9a; letter-spacing: 0.08em;">Fingering Pattern</label>
      <select id="fingeringPatternSelect" style="padding: 0.5rem 0.75rem; border: 1px solid #2a2a3a; border-radius: 8px; font-size: 0.875rem; font-weight: 500; background: #14141f; color: #e8e8eb; cursor: pointer; transition: all 0.2s; height: 38px;">
        <option value="all">All Tones</option>
      </select>
    </div>

    <div style="display: flex; flex-direction: column; gap: 0.25rem;">
      <label style="text-transform: uppercase; font-size: 0.75rem; font-weight: 600; color: #8a8a9a; letter-spacing: 0.08em;">Instrument</label>
      <select id="instrumentSelect" style="padding: 0.5rem 0.75rem; border: 1px solid #2a2a3a; border-radius: 8px; font-size: 0.875rem; font-weight: 500; background: #14141f; color: #e8e8eb; cursor: pointer; transition: all 0.2s; height: 38px;">
        <option value="guitar">Guitar</option>
        <option value="cello">Cello</option>
      </select>
    </div>

    <div style="display: flex; flex-direction: column; gap: 0.25rem;">
      <label style="text-transform: uppercase; font-size: 0.75rem; font-weight: 600; color: transparent; letter-spacing: 0.08em; user-select: none;">.</label>
      <button id="playButton" class="control-btn" style="width: auto; padding: 0 1rem; height: 38px;" title="Play scale">
        ‚ñ∂ Play
      </button>
    </div>

    <div style="display: flex; flex-direction: column; gap: 0.25rem;">
      <label style="text-transform: uppercase; font-size: 0.75rem; font-weight: 600; color: transparent; letter-spacing: 0.08em; user-select: none;">.</label>
      <div style="display: flex; gap: 0.5rem;">
        <button id="exportButton" class="control-btn" style="width: auto; padding: 0 1rem; height: 38px;" title="Export current scale as JSON">
          ‚¨á Export
        </button>
        <button id="importButton" class="control-btn" style="width: auto; padding: 0 1rem; height: 38px;" title="Import scale from JSON">
          ‚¨Ü Import
        </button>
      </div>
      <input type="file" id="importFileInput" accept=".json" style="display: none;" />
    </div>

    <div style="display: flex; flex-direction: column; gap: 0.25rem;">
      <label style="text-transform: uppercase; font-size: 0.75rem; font-weight: 600; color: #8a8a9a; letter-spacing: 0.08em;">Metronome</label>
      <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
        <button id="metronomeToggle" class="control-btn" style="width: auto; padding: 0 0.75rem; height: 38px;" title="Toggle metronome">
          Off
        </button>
        <select id="metronomeSound" style="padding: 0.5rem 0.75rem; border: 1px solid #2a2a3a; border-radius: 8px; font-size: 0.875rem; font-weight: 500; background: #14141f; color: #e8e8eb; cursor: pointer; transition: all 0.2s; height: 38px; min-width: 100px;">
          <option value="woodblock">Woodblock</option>
          <option value="click">Click</option>
          <option value="beep">Beep</option>
          <option value="cowbell">Cowbell</option>
        </select>
        <div style="display: flex; align-items: center; gap: 0.25rem;">
          <button id="metronomeBpmDown" class="control-btn" style="width: 28px; height: 38px; padding: 0; font-size: 16px;" title="Decrease BPM">‚àí</button>
          <input
            type="number"
            id="metronomeBpm"
            value="72"
            min="30"
            max="240"
            style="width: 50px; padding: 0.5rem 0.25rem; border: 1px solid #2a2a3a; border-radius: 8px; font-size: 0.875rem; background: #14141f; color: #e8e8eb; text-align: center;"
          />
          <button id="metronomeBpmUp" class="control-btn" style="width: 28px; height: 38px; padding: 0; font-size: 16px;" title="Increase BPM">+</button>
          <span style="font-size: 0.75rem; color: #8a8a9a;">BPM</span>
        </div>
      </div>
    </div>
  </div>

  <div class="fretboard-container">
    <div class="fretboard-controls">
      <!-- Fret Range -->
      <div class="control-section">
        <span class="control-label">Frets</span>
        <button class="control-btn" id="fretRangeMinus" title="Show fewer frets">‚àí</button>
        <span id="fretRangeDisplay" style="font-size: 0.813rem; color: #e8e8eb; min-width: 40px; text-align: center;">0-24</span>
        <button class="control-btn" id="fretRangePlus" title="Show more frets">+</button>
      </div>

      <div class="divider"></div>

      <!-- Hand Span -->
      <div class="control-section">
        <span class="control-label">Span</span>
        <button class="control-btn" data-span="4" title="4 frets">4</button>
        <button class="control-btn" data-span="5" title="5 frets">5</button>
        <button class="control-btn" data-span="6" title="6 frets">6</button>
        <button class="control-btn active" data-span="0" title="Show all notes">Off</button>
      </div>

      <div class="divider"></div>

      <!-- Display Options -->
      <div class="control-section">
        <span class="control-label">Show</span>
        <button class="control-btn active" id="toggleDisplay" title="Showing notes (click for degrees)">‚ô™</button>
      </div>

      <div class="divider"></div>

      <!-- Zoom -->
      <div class="control-section">
        <span class="control-label">Zoom</span>
        <button class="control-btn" id="zoomOut" title="Zoom out">‚àí</button>
        <button class="control-btn" id="resetZoom" title="Reset zoom">‚äô</button>
        <button class="control-btn" id="zoomIn" title="Zoom in">+</button>
      </div>

      <div class="divider"></div>

      <!-- Marker Style -->
      <div class="control-section">
        <span class="control-label">Markers</span>
        <button class="control-btn active" data-markers="dots" title="Standard dots">‚óè</button>
        <button class="control-btn" data-markers="blocks" title="Gibson blocks">‚ñ¨</button>
        <button class="control-btn" data-markers="birds" title="PRS birds">üê¶</button>
        <button class="control-btn" data-markers="small" title="Fender dots">‚Ä¢</button>
        <button class="control-btn" data-markers="none" title="No markers">‚óã</button>
      </div>
    </div>

    <canvas id="fretboardCanvas" width="2400" height="300"></canvas>

    <div class="info" id="info">
      Drag the blue box to move your practice position
    </div>

    <!-- Chord Explorer -->
    <div id="chordExplorerSection" style="display: none; padding: 1rem 1.25rem;">
      <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem;">
        <div id="chordExplorerHeader" style="font-size: 0.75rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em;">
          Chord Explorer
        </div>
        <button id="clearChordBtn" style="padding: 0.25rem 0.5rem; font-size: 0.75rem; border-radius: 4px; cursor: pointer;">
          Show All Scale Tones
        </button>
      </div>
      <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center;">
        <div id="chordsTriadsList" style="display: flex; flex-wrap: wrap; gap: 0.5rem;"></div>
        <div id="chords7thList" style="display: flex; flex-wrap: wrap; gap: 0.5rem;"></div>
      </div>
    </div>

    <!-- Chord Voicings Display -->
    <div id="chordVoicingsSection" style="display: none; padding: 1rem 1.25rem;">
      <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem;">
        <div id="chordVoicingsHeader" style="font-size: 0.75rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em;">
          Chord Voicings
        </div>
        <button id="closeVoicingsBtn" style="padding: 0.25rem 0.5rem; font-size: 0.75rem; border-radius: 4px; cursor: pointer;">
          Close
        </button>
      </div>
      <div id="chordDiagramsContainer" style="display: flex; gap: 1.5rem; flex-wrap: wrap; justify-content: flex-start;"></div>
    </div>

    <div id="progressionsSection" style="display: none; padding: 1rem 1.25rem;">
      <div id="progressionsHeader" style="font-size: 0.75rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.08em; margin-bottom: 0.75rem;">
        Practice Over
      </div>
      <div id="progressionsList" style="display: flex; flex-direction: column; gap: 0.5rem;"></div>
    </div>
  </div>

  <footer>
    Guitar Scale Explorer - Full Fretboard View - v2.3.1 - Deployed on GitHub Pages
  </footer>

  <script>
    console.log('Guitar Scale Explorer v2.3.1 - Full Fretboard Edition');

    // Constants
    const STANDARD_TUNING = [4, 9, 2, 7, 11, 4]; // E A D G B E (in semitones from C)
    const NOTE_NAMES_SHARPS = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const NOTE_NAMES_FLATS = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
    const NOTE_NAMES = NOTE_NAMES_SHARPS; // Default to sharps for backwards compatibility
    const NOTE_TO_SEMITONE = {
      'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3,
      'E': 4, 'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8,
      'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
    };
    const PREFERRED_ROOTS_SHARPS = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const PREFERRED_ROOTS_FLATS = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
    const ALL_ROOTS = PREFERRED_ROOTS_SHARPS; // Default to sharps for backwards compatibility
    const ENHARMONIC_MAP = {
      'C#': 'Db', 'Db': 'C#',
      'D#': 'Eb', 'Eb': 'D#',
      'F#': 'Gb', 'Gb': 'F#',
      'G#': 'Ab', 'Ab': 'G#',
      'A#': 'Bb', 'Bb': 'A#'
    };

    // State
    const state = {
      scales: [],
      currentScale: null,
      currentScaleData: null,
      selectedScaleId: null,
      selectedFingeringPattern: 'all',
      selectedChord: null,
      diatonicChords: [],
      enharmonicPreference: 'sharps', // 'sharps' or 'flats' - default to sharps to match NOTE_NAMES
      categoriesCollapsed: JSON.parse(localStorage.getItem('categoriesCollapsed') || '{}'),
      dropdownOpen: false,
      fretMin: 0,
      fretMax: 24,
      practicePositionStart: 0,
      handSpan: 0,
      zoom: 1.0,
      showDegrees: false, // true = show degrees (#), false = show note names (‚ô™)
      isDragging: false,
      dragStartX: 0,
      dragStartFret: 0,
      theme: 'dark',
      markerStyle: 'dots',
      metronomeEnabled: false,
      metronomeBpm: 72,
      metronomeSound: 'woodblock',
      viewMode: 'fretboard' // 'fretboard' or 'position'
    };

    // Theme colors
    const themes = {
      dark: {
        bodyBg: 'linear-gradient(135deg, #0a0a0f 0%, #14141f 100%)',
        cardBg: '#1a1a27',
        cardBorder: '#2a2a3a',
        controlBg: '#14141f',
        textPrimary: '#ffffff',
        textSecondary: '#e8e8eb',
        textMuted: '#8a8a9a',
        buttonBg: '#1a1a27',
        buttonBorder: '#2a2a3a',
        buttonText: '#b8b8c8',
        buttonHoverBg: '#24243a',
        buttonHoverBorder: '#3a3a4a',
        selectBg: '#14141f',
        selectBorder: '#2a2a3a',
        canvasBg: '#1a1a27',
        stringColor: '#3a3a4a',
        fretColor: '#2a2a3a',
        nutColor: '#4a4a5a',
        markerColor: '#2a2a3a',
        labelColor: '#6a6a7a',
        practiceBoxBg: 'rgba(74, 158, 255, 0.12)',
        practiceBoxBorder: '#4a9eff',
        noteColor: '#4a9eff',
        rootColor: '#fb923c',
        noteLabelColor: '#b8b8c8'
      },
      light: {
        bodyBg: 'linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%)',
        cardBg: '#ffffff',
        cardBorder: '#dee2e6',
        controlBg: '#f8f9fa',
        textPrimary: '#1a1a1a',
        textSecondary: '#343a40',
        textMuted: '#6c757d',
        buttonBg: '#ffffff',
        buttonBorder: '#dee2e6',
        buttonText: '#495057',
        buttonHoverBg: '#e9ecef',
        buttonHoverBorder: '#adb5bd',
        selectBg: '#ffffff',
        selectBorder: '#dee2e6',
        canvasBg: '#ffffff',
        stringColor: '#adb5bd',
        fretColor: '#ced4da',
        nutColor: '#8a8a9a',
        markerColor: '#e9ecef',
        labelColor: '#868e96',
        practiceBoxBg: 'rgba(74, 158, 255, 0.08)',
        practiceBoxBorder: '#4a9eff',
        noteColor: '#0d6efd',
        rootColor: '#fd7e14',
        noteLabelColor: '#495057'
      }
    };

    // DOM elements
    const canvas = document.getElementById('fretboardCanvas');
    const ctx = canvas.getContext('2d');
    const scaleSelectButton = document.getElementById('scaleSelectButton');
    const scaleSelectValue = document.getElementById('scaleSelectValue');
    const scaleSelectDropdown = document.getElementById('scaleSelectDropdown');
    const rootSelect = document.getElementById('rootSelect');
    const fingeringPatternSelect = document.getElementById('fingeringPatternSelect');
    const fingeringPatternContainer = document.getElementById('fingeringPatternContainer');

    // Audio setup
    let synth = null;
    let isPlaying = false;

    // Metronome setup
    let metronomeSynth = null;
    let metronomeLoop = null;

    function initMetronome(soundType = 'woodblock') {
      if (metronomeSynth) {
        metronomeSynth.dispose();
      }

      const soundConfigs = {
        woodblock: {
          synth: new Tone.MembraneSynth({
            pitchDecay: 0.05,
            octaves: 4,
            envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
          }),
          note: 'G5',
          duration: '32n',
          volume: -8
        },
        click: {
          synth: new Tone.MembraneSynth({
            pitchDecay: 0.008,
            octaves: 2,
            envelope: { attack: 0.0006, decay: 0.05, sustain: 0, release: 0.02 }
          }),
          note: 'C6',
          duration: '64n',
          volume: -5
        },
        beep: {
          synth: new Tone.Synth({
            oscillator: { type: 'sine' },
            envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.05 }
          }),
          note: 'C6',
          duration: '16n',
          volume: -10
        },
        cowbell: {
          synth: new Tone.MetalSynth({
            frequency: 800,
            envelope: { attack: 0.001, decay: 0.1, release: 0.05 },
            harmonicity: 5.1,
            modulationIndex: 32,
            resonance: 4000,
            octaves: 1.5
          }),
          note: 'C4',
          duration: '16n',
          volume: -12
        }
      };

      const config = soundConfigs[soundType] || soundConfigs.woodblock;
      metronomeSynth = config.synth.toDestination();
      metronomeSynth.volume.value = config.volume;

      // Store config for playback
      metronomeSynth._config = config;
    }

    function startMetronome() {
      if (metronomeLoop) {
        metronomeLoop.stop();
        metronomeLoop.dispose();
      }

      if (!metronomeSynth) {
        initMetronome(state.metronomeSound);
      }

      const bpm = state.metronomeBpm;
      Tone.Transport.bpm.value = bpm;

      const config = metronomeSynth._config;
      metronomeLoop = new Tone.Loop((time) => {
        metronomeSynth.triggerAttackRelease(config.note, config.duration, time);
      }, '4n');

      Tone.Transport.start();
      metronomeLoop.start(0);
    }

    function stopMetronome() {
      if (metronomeLoop) {
        metronomeLoop.stop();
        Tone.Transport.stop();
      }
    }

    // MIDI note numbers for open strings (standard tuning)
    const OPEN_STRING_MIDI = {
      6: 40,  // E2
      5: 45,  // A2
      4: 50,  // D3
      3: 55,  // G3
      2: 59,  // B3
      1: 64   // E4
    };

    /**
     * Initialize audio synthesizer with instrument sound
     */
    function initAudio(instrument = 'guitar') {
      if (synth) {
        synth.dispose();
      }

      if (instrument === 'guitar') {
        synth = new Tone.PolySynth(Tone.Synth, {
          oscillator: { type: 'triangle' },
          envelope: { attack: 0.005, decay: 0.3, sustain: 0.1, release: 1.2 }
        }).toDestination();
        synth.volume.value = -8;
      } else if (instrument === 'cello') {
        synth = new Tone.PolySynth(Tone.Synth, {
          oscillator: { type: 'sawtooth' },
          envelope: { attack: 0.05, decay: 0.3, sustain: 0.6, release: 1.5 }
        }).toDestination();
        synth.volume.value = -10;
      }
    }

    /**
     * Convert fretboard position to MIDI note number
     */
    function positionToMidi(string, fret) {
      return OPEN_STRING_MIDI[string] + fret;
    }

    /**
     * Convert MIDI note number to note name (e.g., 60 -> "C4")
     */
    function midiToNoteName(midiNote) {
      const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      const octave = Math.floor(midiNote / 12) - 1;
      const noteName = noteNames[midiNote % 12];
      return noteName + octave;
    }

    /**
     * Collect notes from current scale for playback
     */
    function collectScaleNotes() {
      if (!state.currentScaleData) return [];

      const root = state.currentScaleData.root;
      const intervals = (state.currentScaleData.properties?.intervals || state.currentScaleData.intervals || []).map(i => parseInt(i));
      const degrees = state.currentScaleData.properties?.scale_degrees || state.currentScaleData.scale_degrees || [];

      // Get all positions
      const allPositions = calculateFullFretboard(root, intervals, degrees);

      // Sort by pitch (MIDI note number)
      const sortedNotes = allPositions
        .map(pos => ({
          midi: positionToMidi(pos.string, pos.fret),
          string: pos.string,
          fret: pos.fret,
          note: pos.note,
          degree: pos.degree,
          isRoot: pos.isRoot
        }))
        .sort((a, b) => a.midi - b.midi);

      // Remove duplicates (same MIDI note) and limit to 9 notes
      const uniqueNotes = [];
      const seenMidi = new Set();

      for (const note of sortedNotes) {
        if (!seenMidi.has(note.midi)) {
          seenMidi.add(note.midi);
          uniqueNotes.push(note);
          if (uniqueNotes.length >= 9) break;
        }
      }

      return uniqueNotes;
    }

    /**
     * Play the scale or arpeggio
     */
    async function playScale() {
      if (isPlaying) return;

      const notes = collectScaleNotes();
      if (notes.length === 0) {
        console.log('No notes to play');
        return;
      }

      isPlaying = true;
      const playButton = document.getElementById('playButton');
      playButton.textContent = '‚è∏ Playing...';
      playButton.disabled = true;

      // Ensure audio context is started
      await Tone.start();

      if (!synth) {
        const instrument = document.getElementById('instrumentSelect').value;
        initAudio(instrument);
      }

      // Play notes sequentially
      const noteDuration = '8n';  // Eighth note
      const now = Tone.now();

      notes.forEach((note, index) => {
        const noteName = midiToNoteName(note.midi);
        const time = now + index * 0.3;  // 300ms between notes
        synth.triggerAttackRelease(noteName, noteDuration, time);
      });

      // Reset button after playing
      setTimeout(() => {
        isPlaying = false;
        playButton.textContent = '‚ñ∂ Play';
        playButton.disabled = false;
      }, notes.length * 300 + 500);
    }

    /**
     * Apply theme by toggling data-theme attribute
     */
    function applyTheme() {
      // Set theme attribute on root element for CSS variables
      document.documentElement.setAttribute('data-theme', state.theme);

      // Update theme toggle icon
      document.getElementById('themeIcon').textContent = state.theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';

      // Redraw canvas with new theme colors
      drawFretboard();
    }

    /**
     * Calculate all positions of a scale across the entire fretboard
     */
    function calculateFullFretboard(root, scaleIntervals, scaleDegrees) {
      const rootSemitone = NOTE_TO_SEMITONE[root];
      const positions = [];

      for (let string = 6; string >= 1; string--) {
        const openStringSemitone = STANDARD_TUNING[6 - string];

        for (let fret = 0; fret <= 24; fret++) {
          const noteSemitone = (openStringSemitone + fret) % 12;
          const intervalFromRoot = (noteSemitone - rootSemitone + 12) % 12;

          const degreeIndex = scaleIntervals.indexOf(intervalFromRoot);
          if (degreeIndex !== -1) {
            const noteNames = state.enharmonicPreference === 'sharps' ? NOTE_NAMES_SHARPS : NOTE_NAMES_FLATS;
            const note = noteNames[noteSemitone];
            const degree = scaleDegrees[degreeIndex];
            const isRoot = intervalFromRoot === 0;

            positions.push({
              string: string,
              fret: fret,
              note: note,
              degree: degree,
              isRoot: isRoot,
              intervalFromRoot: intervalFromRoot
            });
          }
        }
      }

      return positions;
    }

    function calculateFingeringPatternPositions(scaleData, root, patternKey) {
      const fingeringVariations = scaleData.properties?.fingering_variations;
      if (!fingeringVariations || !fingeringVariations[patternKey]) {
        return [];
      }

      const pattern = fingeringVariations[patternKey];
      const frets = pattern.frets;
      const scaleIntervals = (scaleData.properties?.intervals || scaleData.intervals || []).map(i => parseInt(i));
      const scaleDegrees = scaleData.properties?.scale_degrees || scaleData.scale_degrees || scaleData.degrees || [];

      // Calculate transposition offset
      const originalRoot = scaleData.starting_tone || scaleData.root || 'A';
      const semitoneShift = (NOTE_TO_SEMITONE[root] - NOTE_TO_SEMITONE[originalRoot] + 12) % 12;

      const positions = [];
      const rootSemitone = NOTE_TO_SEMITONE[root];

      // Iterate through each string in the pattern
      Object.keys(frets).forEach(stringKey => {
        const stringNum = parseInt(stringKey);
        const stringFrets = frets[stringKey];

        stringFrets.forEach(fretStr => {
          const originalFret = parseInt(fretStr);
          const transposedFret = originalFret + semitoneShift;

          // Calculate the note at this position
          const openStringSemitone = STANDARD_TUNING[6 - stringNum];
          const noteSemitone = (openStringSemitone + transposedFret) % 12;
          const intervalFromRoot = (noteSemitone - rootSemitone + 12) % 12;

          // Find the degree for this interval
          const degreeIndex = scaleIntervals.indexOf(intervalFromRoot);
          if (degreeIndex !== -1) {
            const noteNames = state.enharmonicPreference === 'sharps' ? NOTE_NAMES_SHARPS : NOTE_NAMES_FLATS;
            const note = noteNames[noteSemitone];
            const degree = scaleDegrees[degreeIndex];
            const isRoot = intervalFromRoot === 0;

            positions.push({
              string: stringNum,
              fret: transposedFret,
              note: note,
              degree: degree,
              isRoot: isRoot,
              intervalFromRoot: intervalFromRoot
            });
          }
        });
      });

      return positions;
    }

    function calculateChordVoicingPositions(scaleData, root) {
      const voicing = scaleData.properties?.voicing;
      if (!voicing) {
        return [];
      }

      const chordIntervals = (scaleData.properties?.intervals || []).map(i => parseInt(i));
      const chordDegrees = scaleData.properties?.chord_degrees || scaleData.properties?.scale_degrees || [];
      const positions = [];
      const rootSemitone = NOTE_TO_SEMITONE[root];

      Object.keys(voicing).forEach(stringKey => {
        const stringNum = parseInt(stringKey);
        const voicingData = voicing[stringKey];

        if (voicingData !== "mute" && typeof voicingData === 'object') {
          const fret = parseInt(voicingData.fret);
          const note = voicingData.note;

          // Calculate interval from root
          const noteSemitone = NOTE_TO_SEMITONE[note.replace('b', 'flat').replace('#', 'sharp')] || NOTE_TO_SEMITONE[note];
          const intervalFromRoot = (noteSemitone - rootSemitone + 12) % 12;

          // Find the degree for this interval
          const degreeIndex = chordIntervals.indexOf(intervalFromRoot);
          const degree = degreeIndex !== -1 ? chordDegrees[degreeIndex] : '?';
          const isRoot = intervalFromRoot === 0;

          positions.push({
            string: stringNum,
            fret: fret,
            note: note,
            degree: degree,
            isRoot: isRoot,
            intervalFromRoot: intervalFromRoot
          });
        }
      });

      return positions;
    }

    /**
     * Draw the fretboard (routes to different views based on viewMode)
     */
    function drawFretboard() {
      if (!state.currentScaleData) return;

      if (state.viewMode === 'position') {
        drawPositionView();
      } else {
        drawFretboardView();
      }
    }

    /**
     * Draw position-based staves view (tablature style)
     */
    function drawPositionView() {
      if (!state.currentScaleData) return;

      const { showDegrees, theme } = state;
      const colors = themes[theme];
      const scaleData = state.currentScaleData;
      const root = scaleData.root;

      // Check if scale has fingering variations
      const fingeringVariations = scaleData.properties?.fingering_variations;
      if (!fingeringVariations || Object.keys(fingeringVariations).length === 0) {
        // No fingering data - show message
        const width = canvas.width;
        const height = canvas.height;
        ctx.fillStyle = colors.canvasBg;
        ctx.fillRect(0, 0, width, height);
        ctx.fillStyle = colors.textMuted;
        ctx.font = '16px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('Position view requires fingering variation data', width / 2, height / 2);
        ctx.font = '14px sans-serif';
        ctx.fillText('Switch to fretboard view (üé∏ button)', width / 2, height / 2 + 25);
        return;
      }

      const width = canvas.width;
      const height = canvas.height;

      ctx.fillStyle = colors.canvasBg;
      ctx.fillRect(0, 0, width, height);

      const margin = 60;
      const staveHeight = 200; // Height for each position stave
      const stringSpacing = 25; // Vertical spacing between strings
      const noteSpacing = 50; // Horizontal spacing between notes in sequence

      // Get all fingering variations
      const variations = Object.keys(fingeringVariations);
      let currentY = margin;

      variations.forEach((variationKey, varIndex) => {
        const variation = fingeringVariations[variationKey];
        const frets = variation.frets;

        // Calculate sequence for this variation
        // Play from low E (string 6) to high e (string 1)
        const notesWithSequence = [];
        let sequence = 1;

        // Iterate strings from 6 to 1 (low E to high e)
        for (let stringNum = 6; stringNum >= 1; stringNum--) {
          const stringKey = String(stringNum);
          if (frets[stringKey]) {
            const stringFrets = frets[stringKey];
            stringFrets.forEach(fretStr => {
              const fret = parseInt(fretStr);
              notesWithSequence.push({
                string: stringNum,
                fret: fret,
                sequence: sequence++
              });
            });
          }
        }

        // Draw position label
        ctx.fillStyle = colors.textPrimary;
        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'left';
        ctx.fillText(`Position ${varIndex + 1}: ${variation.description || variationKey}`, margin, currentY - 10);

        // Draw strings (e-B-G-D-A-E from top to bottom, standard tab format)
        const stringNames = ['e', 'B', 'G', 'D', 'A', 'E'];
        for (let i = 0; i < 6; i++) {
          const stringNum = i + 1; // 1, 2, 3, 4, 5, 6 (high e to low E)
          const y = currentY + i * stringSpacing;

          // Draw string line
          ctx.strokeStyle = colors.stringColor;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(margin + 40, y);
          ctx.lineTo(width - margin, y);
          ctx.stroke();

          // Draw string label
          ctx.fillStyle = colors.textMuted;
          ctx.font = 'bold 12px sans-serif';
          ctx.textAlign = 'right';
          ctx.textBaseline = 'middle';
          ctx.fillText(stringNames[i], margin + 30, y);
        }

        // Draw notes
        notesWithSequence.forEach(note => {
          const stringIndex = note.string - 1; // Convert string number to index (0-5)
          const y = currentY + stringIndex * stringSpacing;
          const x = margin + 60 + (note.sequence - 1) * noteSpacing;

          // Draw note circle
          const radius = 10;
          ctx.fillStyle = colors.noteColor;
          ctx.beginPath();
          ctx.arc(x, y, radius, 0, 2 * Math.PI);
          ctx.fill();

          // Draw fret number inside circle
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 11px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(note.fret, x, y);

          // Draw sequence number above circle
          ctx.fillStyle = colors.textMuted;
          ctx.font = '10px sans-serif';
          ctx.fillText(note.sequence, x, y - 18);
        });

        currentY += staveHeight;

        // Check if we have room for another stave
        if (currentY + staveHeight > height) {
          return; // Stop drawing more staves if we run out of space
        }
      });
    }

    /**
     * Draw the traditional fretboard view
     */
    function drawFretboardView() {
      if (!state.currentScaleData) return;

      const { fretMin, fretMax, zoom, showDegrees, theme } = state;
      const colors = themes[theme];

      const scaleData = state.currentScaleData;
      const root = scaleData.root;
      const intervals = (scaleData.properties?.intervals || scaleData.intervals || []).map(i => parseInt(i));
      const degrees = scaleData.properties?.scale_degrees || scaleData.scale_degrees || scaleData.degrees || [];

      // Use fingering pattern positions if a pattern is selected, otherwise show all tones
      let allPositions;
      if (state.selectedFingeringPattern !== 'all') {
        allPositions = calculateFingeringPatternPositions(scaleData, root, state.selectedFingeringPattern);
      } else {
        allPositions = calculateFullFretboard(root, intervals, degrees);
      }

      // Filter by chord tones if a chord is selected
      if (state.selectedChord) {
        const chordIntervals = state.selectedChord.type === 'seventh'
          ? state.selectedChord.intervalsWithSeventh
          : state.selectedChord.intervals;

        allPositions = allPositions.filter(pos => chordIntervals.includes(pos.intervalFromRoot));

        // Add chord tone labels (R, 3, 5, 7)
        allPositions.forEach(pos => {
          const chordToneIndex = chordIntervals.indexOf(pos.intervalFromRoot);
          const chordToneLabels = ['R', '3', '5', '7'];
          pos.chordTone = chordToneLabels[chordToneIndex];
          pos.isChordRoot = chordToneIndex === 0;
        });
      }

      const visiblePositions = allPositions.filter(p =>
        p.fret >= fretMin && p.fret <= fretMax
      );

      const width = canvas.width;
      const height = canvas.height;

      ctx.fillStyle = colors.canvasBg;
      ctx.fillRect(0, 0, width, height);

      if (visiblePositions.length === 0) {
        ctx.fillStyle = colors.textMuted;
        ctx.font = '20px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('No positions in this range', width / 2, height / 2);
        return;
      }

      const margin = 60;
      const stringSpacing = (height - 2 * margin) / 5;
      const fretCount = fretMax - fretMin;
      const fretSpacing = Math.min((width - 2 * margin) / fretCount, 80) * zoom;

      // Draw strings
      ctx.strokeStyle = colors.stringColor;
      ctx.lineWidth = 2;
      for (let i = 0; i < 6; i++) {
        const y = margin + i * stringSpacing;
        ctx.beginPath();
        ctx.moveTo(margin, y);
        ctx.lineTo(margin + fretCount * fretSpacing, y);
        ctx.stroke();

        const stringNum = i + 1;
        ctx.fillStyle = colors.textMuted;
        ctx.font = 'bold 13px sans-serif';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        ctx.fillText(`${stringNum}`, margin - 10, y);
      }

      // Draw frets
      for (let i = 0; i <= fretCount; i++) {
        const fretNumber = fretMin + i;
        const x = margin + i * fretSpacing;

        // Make the nut (between fret 0 and 1) more prominent
        if (fretNumber === 1 && fretMin === 0) {
          ctx.strokeStyle = colors.nutColor;
          ctx.lineWidth = 6;
        } else {
          ctx.strokeStyle = colors.fretColor;
          ctx.lineWidth = 2;
        }

        ctx.beginPath();
        ctx.moveTo(x, margin);
        ctx.lineTo(x, height - margin);
        ctx.stroke();

        if (i < fretCount) {
          if (fretCount > 12 && i % 2 !== 0) continue;
          ctx.fillStyle = colors.labelColor;
          ctx.font = 'bold 12px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          ctx.fillText(fretNumber, x + fretSpacing / 2, height - margin + 15);
        }
      }

      // Draw fret markers
      const markerFrets = [3, 5, 7, 9, 12, 15, 17, 19, 21, 24];
      const markerStyle = state.markerStyle;

      if (markerStyle !== 'none') {
        ctx.fillStyle = colors.markerColor;

        markerFrets.forEach(fret => {
          if (fret >= fretMin && fret <= fretMax) {
            const x = margin + (fret - fretMin - 0.5) * fretSpacing;
            const y = height / 2;
            const isDouble = fret === 12 || fret === 24;

            if (markerStyle === 'dots') {
              // Standard circular dots (7px radius)
              if (isDouble) {
                ctx.beginPath();
                ctx.arc(x, y - 30, 7, 0, 2 * Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x, y + 30, 7, 0, 2 * Math.PI);
                ctx.fill();
              } else {
                ctx.beginPath();
                ctx.arc(x, y, 7, 0, 2 * Math.PI);
                ctx.fill();
              }
            } else if (markerStyle === 'blocks') {
              // Gibson-style block inlays
              const blockWidth = Math.min(fretSpacing * 0.6, 40);
              const blockHeight = 16;
              if (isDouble) {
                ctx.fillRect(x - blockWidth / 2, y - 30 - blockHeight / 2, blockWidth, blockHeight);
                ctx.fillRect(x - blockWidth / 2, y + 30 - blockHeight / 2, blockWidth, blockHeight);
              } else {
                ctx.fillRect(x - blockWidth / 2, y - blockHeight / 2, blockWidth, blockHeight);
              }
            } else if (markerStyle === 'small') {
              // Fender-style small dots (5px radius)
              if (isDouble) {
                ctx.beginPath();
                ctx.arc(x, y - 30, 5, 0, 2 * Math.PI);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(x, y + 30, 5, 0, 2 * Math.PI);
                ctx.fill();
              } else {
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, 2 * Math.PI);
                ctx.fill();
              }
            } else if (markerStyle === 'birds') {
              // PRS-style bird inlays
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.font = '20px serif';
              ctx.fillStyle = colors.markerColor;

              if (isDouble) {
                ctx.fillText('üê¶', x, y - 30);
                ctx.fillText('üê¶', x, y + 30);
              } else {
                ctx.fillText('üê¶', x, y);
              }
            }
          }
        });
      }

      // Draw practice position box (only if span is not 0/Off)
      if (state.handSpan > 0) {
        const practiceStart = state.practicePositionStart;
        const practiceEnd = practiceStart + state.handSpan - 1;

        if (practiceStart >= fretMin && practiceStart <= fretMax) {
          const x1 = margin + (practiceStart - fretMin) * fretSpacing;
          const x2 = margin + (Math.min(practiceEnd, fretMax) - fretMin + 1) * fretSpacing;

          ctx.fillStyle = colors.practiceBoxBg;
          ctx.fillRect(x1, margin - 10, x2 - x1, height - 2 * margin + 20);

          ctx.strokeStyle = colors.practiceBoxBorder;
          ctx.lineWidth = 3;
          if (theme === 'dark') {
            ctx.shadowBlur = 8;
            ctx.shadowColor = 'rgba(74, 158, 255, 0.4)';
          }
          ctx.setLineDash([6, 4]);
          ctx.strokeRect(x1, margin - 10, x2 - x1, height - 2 * margin + 20);
          ctx.setLineDash([]);
          ctx.shadowBlur = 0;

          // Label
          const labelText = `Frets ${practiceStart}-${practiceEnd}`;
          const labelX = (x1 + x2) / 2;
          const labelY = height - margin + 35;

          ctx.font = 'bold 13px sans-serif';
          const textMetrics = ctx.measureText(labelText);
          const pillWidth = textMetrics.width + 16;
          const pillHeight = 24;

          ctx.fillStyle = colors.controlBg;
          ctx.beginPath();
          ctx.roundRect(labelX - pillWidth / 2, labelY - pillHeight / 2, pillWidth, pillHeight, 12);
          ctx.fill();

          ctx.strokeStyle = colors.practiceBoxBorder;
          ctx.lineWidth = 1.5;
          ctx.stroke();

          ctx.fillStyle = colors.practiceBoxBorder;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(labelText, labelX, labelY);
        }
      }

      // Draw notes
      visiblePositions.forEach(pos => {
        const stringIndex = pos.string - 1;
        const fretOffset = pos.fret - fretMin;
        const x = margin + (fretOffset + 0.5) * fretSpacing;
        const y = margin + stringIndex * stringSpacing;
        const radius = Math.min(fretSpacing * 0.35, 16);

        let opacity = 1.0;
        // Only dim notes if span is active (not 0/Off)
        if (state.handSpan > 0) {
          const practiceEnd = state.practicePositionStart + state.handSpan - 1;
          if (pos.fret < state.practicePositionStart || pos.fret > practiceEnd) {
            opacity = 0.2;
          }
        }

        ctx.globalAlpha = opacity;
        if (opacity === 1.0 && theme === 'dark') {
          ctx.shadowBlur = 10;
          ctx.shadowColor = pos.isRoot ? 'rgba(251, 146, 60, 0.5)' : 'rgba(74, 158, 255, 0.5)';
        }
        ctx.fillStyle = pos.isRoot ? colors.rootColor : colors.noteColor;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Draw label inside circle
        ctx.fillStyle = '#ffffff';
        ctx.font = `bold ${Math.min(radius * 0.8, 12)}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        let label = '';
        if (showDegrees) {
          // Show scale degrees/intervals
          label = pos.degree;
        } else {
          // Show note names
          label = pos.note;
        }

        ctx.fillText(label, x, y);

        ctx.globalAlpha = 1.0;
      });
    }

    /**
     * Load scale catalog
     */
    async function loadScaleCatalog() {
      const scaleFiles = [
        'aeolian_3nps', 'altered_dominant', 'arpeggio_2noteperstring_dominant7',
        'arpeggio_2notesperstring_m7b5', 'arpeggio_major_7_2_notes_per_string',
        'arpeggio_minor_7_2_notes_per_string', 'dorian_3nps', 'dorian_b2_3nps',
        'dorian_sharp4_3nps', 'half_whole_diminished', 'harmonic_minor_3nps',
        'hexatonic_pos1', 'ionian_3nps', 'ionian_augmented_3nps', 'jazz_blues_pos1',
        'locrian_3nps', 'locrian_natural2_3nps', 'locrian_natural6_3nps',
        'lydian_3nps', 'lydian_augmented_3nps', 'lydian_dominant_3nps',
        'lydian_sharp2_3nps', 'major_blues_box', 'melodic_minor_3nps',
        'minor_blues_box', 'minor_pentatonic_box2', 'mixolydian_3nps',
        'mixolydian_b6_3nps', 'phrygian_3nps', 'phrygian_dominant_3nps',
        'super_locrian_bb7_3nps', 'whole_tone'
      ];

      const promises = scaleFiles.map(async (filename) => {
        try {
          const response = await fetch(`scales/${filename}.json`);
          const data = await response.json();
          return {
            id: filename,
            name: data.Item.scale_type || filename,
            category: data.Item.properties?.category || 'other',
            data: data.Item
          };
        } catch (err) {
          console.error(`Failed to load ${filename}:`, err);
          return null;
        }
      });

      state.scales = (await Promise.all(promises)).filter(s => s !== null);

      // Load custom scales from localStorage
      loadCustomScalesFromStorage();

      populateScaleSelect();
      populateRootSelect();

      if (state.scales.length > 0) {
        // Set initial selection to Minor Blues Box, fallback to first scale
        const defaultScale = state.scales.find(s => s.id === 'minor_blues_box') || state.scales[0];
        state.selectedScaleId = defaultScale.id;
        scaleSelectValue.textContent = defaultScale.name;
        updateDisplay();
      }
    }

    function populateScaleSelect(filterText = '') {
      scaleSelectDropdown.innerHTML = '';

      const filter = filterText.toLowerCase().trim();

      // Group scales by category
      const categories = {
        'arpeggios': { label: 'Arpeggios', scales: [] },
        'modes_major': { label: 'Major Scale Modes', scales: [] },
        'modes_melodic_minor': { label: 'Melodic Minor Modes', scales: [] },
        'modes_harmonic_minor': { label: 'Harmonic Minor Modes', scales: [] },
        'pentatonic_blues': { label: 'Pentatonic & Blues Scales', scales: [] },
        'symmetrical': { label: 'Symmetrical Scales', scales: [] },
        'scales': { label: 'Other Scales', scales: [] },
        'modes': { label: 'Other Modes', scales: [] }
      };

      state.scales.forEach(scale => {
        // Filter by search text
        if (filter && !scale.name.toLowerCase().includes(filter) && !scale.id.toLowerCase().includes(filter)) {
          return;
        }

        const category = scale.category || 'scales';
        if (categories[category]) {
          categories[category].scales.push(scale);
        }
      });

      let hasResults = false;

      // Helper function to extract mode number from scale name
      function getModeNumber(scaleName) {
        const match = scaleName.match(/Mode (\d+)/);
        return match ? parseInt(match[1]) : 999; // Return 999 for non-mode scales
      }

      // Create custom dropdown structure with collapsible categories
      let scalesHeaderAdded = false;
      ['arpeggios', 'modes_major', 'modes_melodic_minor', 'modes_harmonic_minor', 'pentatonic_blues', 'symmetrical', 'scales', 'modes'].forEach(categoryKey => {
        const category = categories[categoryKey];
        if (category.scales.length > 0) {
          hasResults = true;

          // Add "Scales" parent header before first mode category
          if (categoryKey === 'modes_major' && !scalesHeaderAdded) {
            const scalesHeader = document.createElement('div');
            scalesHeader.className = 'category-header';
            scalesHeader.style.cssText = 'cursor: default; background: #14141f;';
            scalesHeader.innerHTML = `
              <div style="font-weight: 700; color: #4a9eff;">
                üéº Scales
              </div>
            `;
            scaleSelectDropdown.appendChild(scalesHeader);
            scalesHeaderAdded = true;
          }

          // Sort scales by mode number for mode categories, alphabetically for others
          if (categoryKey.startsWith('modes_')) {
            category.scales.sort((a, b) => getModeNumber(a.name) - getModeNumber(b.name));
          } else {
            category.scales.sort((a, b) => a.name.localeCompare(b.name));
          }

          // Determine if category should be collapsed
          const isCollapsed = state.categoriesCollapsed[categoryKey] === true;

          // Category header
          const header = document.createElement('div');
          header.className = `category-header${isCollapsed ? ' collapsed' : ''}`;
          header.dataset.category = categoryKey;

          // Add indentation for subcategories under Scales
          const isScalesSubCategory = categoryKey.startsWith('modes_') || categoryKey === 'scales' || categoryKey === 'modes' || categoryKey === 'pentatonic_blues' || categoryKey === 'symmetrical';
          const indent = isScalesSubCategory ? 'padding-left: 1.5rem;' : '';

          header.style.cssText = indent;
          header.innerHTML = `
            <div>
              <span class="category-icon">‚ñº</span>
              ${isScalesSubCategory ? '‚îî ' : ''}${category.label} (${category.scales.length})
            </div>
          `;
          header.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleCategory(categoryKey);
          });

          scaleSelectDropdown.appendChild(header);

          // Category items container
          const itemsContainer = document.createElement('div');
          itemsContainer.className = `category-items${isCollapsed ? ' collapsed' : ''}`;
          itemsContainer.dataset.category = categoryKey;

          category.scales.forEach(scale => {
            const option = document.createElement('div');
            option.className = 'scale-option';
            if (scale.id === state.selectedScaleId) {
              option.classList.add('selected');
            }
            option.dataset.scaleId = scale.id;
            option.textContent = scale.name;

            // Add extra indentation for subcategory items under Scales
            if (isScalesSubCategory) {
              option.style.paddingLeft = '2.75rem';
            }

            option.addEventListener('click', (e) => {
              e.stopPropagation();
              selectScale(scale.id);
            });

            itemsContainer.appendChild(option);
          });

          scaleSelectDropdown.appendChild(itemsContainer);
        }
      });

      // Show "No results" message if nothing found
      if (!hasResults && filter) {
        const noResults = document.createElement('div');
        noResults.style.cssText = 'padding: 1rem; text-align: center; color: #8a8a9a; font-size: 0.875rem;';
        noResults.textContent = 'No patterns found';
        scaleSelectDropdown.appendChild(noResults);
      }
    }

    // Track hover collapse timers
    const hoverCollapseTimers = {};

    function expandCategory(categoryKey) {
      // Clear any pending collapse timer
      if (hoverCollapseTimers[categoryKey]) {
        clearTimeout(hoverCollapseTimers[categoryKey]);
        delete hoverCollapseTimers[categoryKey];
      }

      state.categoriesCollapsed[categoryKey] = false;

      // Update UI
      const header = scaleSelectDropdown.querySelector(`.category-header[data-category="${categoryKey}"]`);
      const items = scaleSelectDropdown.querySelector(`.category-items[data-category="${categoryKey}"]`);

      if (header && items) {
        header.classList.remove('collapsed');
        items.classList.remove('collapsed');
      }
    }

    function collapseCategory(categoryKey, immediate = false) {
      // Clear any existing timer
      if (hoverCollapseTimers[categoryKey]) {
        clearTimeout(hoverCollapseTimers[categoryKey]);
        delete hoverCollapseTimers[categoryKey];
      }

      const doCollapse = () => {
        state.categoriesCollapsed[categoryKey] = true;

        // Update UI
        const header = scaleSelectDropdown.querySelector(`.category-header[data-category="${categoryKey}"]`);
        const items = scaleSelectDropdown.querySelector(`.category-items[data-category="${categoryKey}"]`);

        if (header && items) {
          header.classList.add('collapsed');
          items.classList.add('collapsed');
        }
      };

      if (immediate) {
        doCollapse();
      } else {
        // Delay before collapsing to prevent accidental closures
        hoverCollapseTimers[categoryKey] = setTimeout(doCollapse, 700);
      }
    }

    function toggleCategory(categoryKey) {
      const isCurrentlyCollapsed = state.categoriesCollapsed[categoryKey] === true;

      if (isCurrentlyCollapsed) {
        expandCategory(categoryKey);
      } else {
        collapseCategory(categoryKey, true); // Immediate collapse on click
      }

      // Save to localStorage
      localStorage.setItem('categoriesCollapsed', JSON.stringify(state.categoriesCollapsed));
    }

    function selectScale(scaleId) {
      state.selectedScaleId = scaleId;

      // Reset fingering pattern and chord selection when switching scales
      state.selectedFingeringPattern = 'all';
      state.selectedChord = null;

      // Update button display
      const scale = state.scales.find(s => s.id === scaleId);
      if (scale) {
        scaleSelectValue.textContent = scale.name;
      }

      // Close dropdown
      closeDropdown();

      // Update the fretboard
      updateDisplay();
    }

    function openDropdown() {
      state.dropdownOpen = true;
      scaleSelectDropdown.style.display = 'block';
      scaleSelectButton.setAttribute('aria-expanded', 'true');
    }

    function closeDropdown() {
      state.dropdownOpen = false;
      scaleSelectDropdown.style.display = 'none';
      scaleSelectButton.setAttribute('aria-expanded', 'false');
    }

    function toggleDropdown() {
      if (state.dropdownOpen) {
        closeDropdown();
      } else {
        openDropdown();
      }
    }

    function populateRootSelect() {
      // IMPORTANT: Save current value BEFORE clearing the select
      const currentValue = rootSelect.value || 'A';
      const roots = state.enharmonicPreference === 'sharps' ? PREFERRED_ROOTS_SHARPS : PREFERRED_ROOTS_FLATS;

      rootSelect.innerHTML = '';

      roots.forEach(root => {
        const option = document.createElement('option');
        option.value = root;
        option.textContent = root;
        rootSelect.appendChild(option);
      });

      // Try to maintain the same pitch if switching enharmonics
      if (currentValue) {
        const currentSemitone = NOTE_TO_SEMITONE[currentValue];
        const matchingRoot = roots.find(r => NOTE_TO_SEMITONE[r] === currentSemitone);
        rootSelect.value = matchingRoot || roots[9]; // Default to A (index 9)
      } else {
        rootSelect.value = 'A';
      }
    }

    function populateFingeringPatternSelect() {
      // TEMPORARILY DISABLED - Issue #29
      // Need to properly define patterns with position shifts before enabling
      fingeringPatternContainer.style.display = 'none';
      state.selectedFingeringPattern = 'all';
      return;

      // const scale = state.scales.find(s => s.id === state.selectedScaleId);
      // if (!scale) return;

      // const fingeringVariations = scale.data.properties?.fingering_variations;

      // // Hide the selector if no fingering variations exist
      // if (!fingeringVariations || Object.keys(fingeringVariations).length === 0) {
      //   fingeringPatternContainer.style.display = 'none';
      //   state.selectedFingeringPattern = 'all';
      //   return;
      // }

      // // Show the selector
      // fingeringPatternContainer.style.display = 'flex';

      // // Populate options
      // fingeringPatternSelect.innerHTML = '';

      // // Always add "All Tones" option
      // const allOption = document.createElement('option');
      // allOption.value = 'all';
      // allOption.textContent = 'All Tones';
      // fingeringPatternSelect.appendChild(allOption);

      // // Add fingering variation options
      // Object.keys(fingeringVariations).forEach(key => {
      //   const variation = fingeringVariations[key];
      //   const option = document.createElement('option');
      //   option.value = key;
      //   option.textContent = variation.description || key;
      //   fingeringPatternSelect.appendChild(option);
      // });

      // // Set current selection
      // fingeringPatternSelect.value = state.selectedFingeringPattern;
    }

    function transposeScale(scaleData, targetRoot) {
      const originalRoot = scaleData.starting_tone || 'A';
      const semitoneShift = (NOTE_TO_SEMITONE[targetRoot] - NOTE_TO_SEMITONE[originalRoot] + 12) % 12;

      return {
        ...scaleData,
        root: targetRoot,
        starting_tone: targetRoot
      };
    }

    function populateChordExplorer() {
      const chordExplorerSection = document.getElementById('chordExplorerSection');
      const chordsTriadsList = document.getElementById('chordsTriadsList');
      const chords7thList = document.getElementById('chords7thList');

      if (state.diatonicChords.length === 0) {
        chordExplorerSection.style.display = 'none';
        return;
      }

      chordExplorerSection.style.display = 'block';
      applyTheme(); // Apply theme after showing section

      // Clear existing chords
      chordsTriadsList.innerHTML = '';
      chords7thList.innerHTML = '';

      // Populate triads
      const theme = themes[state.theme];
      state.diatonicChords.forEach((chord, index) => {
        if (chord.triadSymbol) {
          const btn = document.createElement('button');
          btn.textContent = chord.triadSymbol;
          btn.dataset.chordIndex = index;
          btn.dataset.chordType = 'triad';
          btn.className = 'chord-btn';
          btn.style.cssText = `padding: 0.375rem 0.75rem; font-size: 0.813rem; background: ${theme.buttonBg}; color: ${theme.buttonText}; border: 1px solid ${theme.buttonBorder}; border-radius: 6px; cursor: pointer; transition: all 0.2s; font-weight: 500;`;
          btn.addEventListener('click', () => selectChord(chord, 'triad'));
          btn.addEventListener('mouseenter', function() {
            if (!this.classList.contains('selected-chord')) {
              const hoverTheme = themes[state.theme];
              this.style.background = hoverTheme.buttonBgHover || hoverTheme.buttonBg;
              this.style.borderColor = '#4a9eff';
            }
          });
          btn.addEventListener('mouseleave', function() {
            if (!this.classList.contains('selected-chord')) {
              const defaultTheme = themes[state.theme];
              this.style.background = defaultTheme.buttonBg;
              this.style.borderColor = defaultTheme.buttonBorder;
            }
          });
          chordsTriadsList.appendChild(btn);
        }
      });

      // Populate 7th chords
      state.diatonicChords.forEach((chord, index) => {
        if (chord.seventhSymbol) {
          const btn = document.createElement('button');
          btn.textContent = chord.seventhSymbol;
          btn.dataset.chordIndex = index;
          btn.dataset.chordType = 'seventh';
          btn.className = 'chord-btn';
          btn.style.cssText = `padding: 0.375rem 0.75rem; font-size: 0.813rem; background: ${theme.buttonBg}; color: ${theme.buttonText}; border: 1px solid ${theme.buttonBorder}; border-radius: 6px; cursor: pointer; transition: all 0.2s; font-weight: 500;`;
          btn.addEventListener('click', () => selectChord(chord, 'seventh'));
          btn.addEventListener('mouseenter', function() {
            if (!this.classList.contains('selected-chord')) {
              const hoverTheme = themes[state.theme];
              this.style.background = hoverTheme.buttonBgHover || hoverTheme.buttonBg;
              this.style.borderColor = '#4a9eff';
            }
          });
          btn.addEventListener('mouseleave', function() {
            if (!this.classList.contains('selected-chord')) {
              const defaultTheme = themes[state.theme];
              this.style.background = defaultTheme.buttonBg;
              this.style.borderColor = defaultTheme.buttonBorder;
            }
          });
          chords7thList.appendChild(btn);
        }
      });
    }

    function selectChord(chord, type) {
      state.selectedChord = { ...chord, type };

      const theme = themes[state.theme];

      // Update button styles
      document.querySelectorAll('#chordsTriadsList button, #chords7thList button').forEach(btn => {
        btn.classList.remove('selected-chord');
        btn.style.background = theme.buttonBg;
        btn.style.borderColor = theme.buttonBorder;
        btn.style.color = theme.buttonText;
      });

      // Highlight selected button
      const selectedButtons = document.querySelectorAll(`button[data-chord-index="${chord.degree - 1}"][data-chord-type="${type}"]`);
      selectedButtons.forEach(btn => {
        btn.classList.add('selected-chord');
        btn.style.background = '#4a9eff';
        btn.style.borderColor = '#4a9eff';
        btn.style.color = '#ffffff';
      });

      // Load chord voicings - extract chord type from symbol
      const symbol = type === 'seventh' ? chord.seventhSymbol : chord.triadSymbol;
      loadChordVoicings(chord.root, symbol);

      drawFretboard();
    }

    function clearChordSelection() {
      state.selectedChord = null;

      const theme = themes[state.theme];

      // Reset button styles
      document.querySelectorAll('#chordsTriadsList button, #chords7thList button').forEach(btn => {
        btn.classList.remove('selected-chord');
        btn.style.background = theme.buttonBg;
        btn.style.borderColor = theme.buttonBorder;
        btn.style.color = theme.buttonText;
      });

      // Hide chord voicings section
      document.getElementById('chordVoicingsSection').style.display = 'none';

      drawFretboard();
    }

    function calculateDiatonicChords(root, intervals) {
      const rootSemitone = NOTE_TO_SEMITONE[root];
      const chords = [];

      // Roman numerals for chord degrees
      const majorRomanNumerals = ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII'];
      const minorRomanNumerals = ['i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii'];

      // Build a chord from each scale degree
      intervals.forEach((rootInterval, index) => {
        // Stack thirds to build chord (root, 3rd, 5th, 7th)
        const third = intervals[(index + 2) % intervals.length];
        const fifth = intervals[(index + 4) % intervals.length];
        const seventh = intervals[(index + 6) % intervals.length];

        // Calculate interval sizes
        const thirdSize = (third - rootInterval + 12) % 12;
        const fifthSize = (fifth - rootInterval + 12) % 12;
        const seventhSize = (seventh - rootInterval + 12) % 12;

        // Determine chord quality
        const isMajorThird = thirdSize === 4;
        const isMinorThird = thirdSize === 3;
        const isPerfectFifth = fifthSize === 7;
        const isDiminishedFifth = fifthSize === 6;
        const isAugmentedFifth = fifthSize === 8;
        const isMajorSeventh = seventhSize === 11;
        const isMinorSeventh = seventhSize === 10;

        // Calculate the chord root note
        const chordRootSemitone = (rootSemitone + rootInterval) % 12;
        const noteNames = state.enharmonicPreference === 'sharps' ? NOTE_NAMES_SHARPS : NOTE_NAMES_FLATS;
        const chordRoot = noteNames[chordRootSemitone];

        // Determine chord symbol and quality
        let triadSymbol = '';
        let seventhSymbol = '';
        let romanNumeral = '';

        // Triad quality
        if (isMajorThird && isPerfectFifth) {
          triadSymbol = chordRoot;
          romanNumeral = majorRomanNumerals[index];
        } else if (isMinorThird && isPerfectFifth) {
          triadSymbol = chordRoot + 'm';
          romanNumeral = minorRomanNumerals[index];
        } else if (isMinorThird && isDiminishedFifth) {
          triadSymbol = chordRoot + 'dim';
          romanNumeral = minorRomanNumerals[index] + '¬∞';
        } else if (isMajorThird && isAugmentedFifth) {
          triadSymbol = chordRoot + 'aug';
          romanNumeral = majorRomanNumerals[index] + '+';
        }

        // 7th chord quality
        if (isMajorThird && isPerfectFifth && isMajorSeventh) {
          seventhSymbol = chordRoot + 'maj7';
        } else if (isMinorThird && isPerfectFifth && isMinorSeventh) {
          seventhSymbol = chordRoot + 'm7';
        } else if (isMajorThird && isPerfectFifth && isMinorSeventh) {
          seventhSymbol = chordRoot + '7';
        } else if (isMinorThird && isDiminishedFifth && isMinorSeventh) {
          seventhSymbol = chordRoot + 'm7b5';
        } else if (isMinorThird && isDiminishedFifth && (seventhSize === 9)) {
          seventhSymbol = chordRoot + 'dim7';
        } else if (isMinorThird && isPerfectFifth && isMajorSeventh) {
          seventhSymbol = chordRoot + 'mMaj7';
        } else if (isMajorThird && isAugmentedFifth && isMajorSeventh) {
          seventhSymbol = chordRoot + 'maj7#5';
        }

        chords.push({
          root: chordRoot,
          triadSymbol: triadSymbol,
          seventhSymbol: seventhSymbol,
          romanNumeral: romanNumeral,
          intervals: [rootInterval, third, fifth],
          intervalsWithSeventh: [rootInterval, third, fifth, seventh],
          degree: index + 1
        });
      });

      return chords;
    }

    function renderProgressions() {
      if (!state.currentScaleData) return;

      const progressions = state.currentScaleData.properties?.progressions || [];
      const progressionsSection = document.getElementById('progressionsSection');
      const progressionsList = document.getElementById('progressionsList');
      const root = rootSelect.value;

      if (progressions.length > 0) {
        progressionsList.innerHTML = '';
        progressions.forEach(prog => {
          displayProgressionWithDiagrams(prog, root, progressionsList);
        });
        progressionsSection.style.display = 'block';
        applyTheme(); // Apply theme after showing section
      } else {
        progressionsSection.style.display = 'none';
      }
    }

    function updateDisplay() {
      const scale = state.scales.find(s => s.id === state.selectedScaleId);
      if (!scale) return;

      const root = rootSelect.value;
      const transposed = transposeScale(scale.data, root);

      state.currentScaleData = transposed;
      state.currentScale = scale;

      // Update fingering pattern selector
      populateFingeringPatternSelect();

      document.getElementById('info').textContent =
        `${scale.name} in ${root} - Drag the blue box to move your practice position`;

      // Display chord progressions if available
      renderProgressions();

      // Calculate and display diatonic chords
      const intervals = (transposed.properties?.intervals || transposed.intervals || []).map(i => parseInt(i));
      if (intervals.length >= 7) {
        state.diatonicChords = calculateDiatonicChords(root, intervals);
        populateChordExplorer();
      } else {
        // Hide chord explorer for scales with less than 7 notes
        document.getElementById('chordExplorerSection').style.display = 'none';
        state.selectedChord = null;
      }

      drawFretboard();
    }

    /**
     * Export current scale as JSON file
     */
    function exportScale() {
      if (!state.currentScaleData || !state.currentScale) {
        alert('No scale loaded to export');
        return;
      }

      const root = rootSelect.value;
      const scaleName = state.currentScale.name.replace(/\s+/g, '_').toLowerCase();
      const filename = `${scaleName}_${root}.json`;

      // Create JSON structure matching the format
      const exportData = {
        TableName: "GuitarExercises",
        Item: state.currentScaleData
      };

      // Create blob and download
      const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      console.log(`Exported scale: ${filename}`);
    }

    /**
     * Import scale from JSON file
     */
    function importScale(file) {
      const reader = new FileReader();

      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);

          // Validate JSON structure
          if (!data.Item || !data.Item.exercise) {
            alert('Invalid scale JSON format: missing Item.exercise');
            return;
          }

          const item = data.Item;

          // Validate required fields
          if (!item.scale_type || !item.starting_tone || !item.properties) {
            alert('Invalid scale JSON format: missing required fields (scale_type, starting_tone, properties)');
            return;
          }

          // Add to custom scales in localStorage
          saveCustomScale(item);

          // Reload catalog to include the new scale
          loadCustomScalesFromStorage();

          alert(`Successfully imported: ${item.scale_type}`);
        } catch (err) {
          alert(`Failed to import scale: ${err.message}`);
          console.error('Import error:', err);
        }
      };

      reader.readAsText(file);
    }

    /**
     * Save custom scale to localStorage
     */
    function saveCustomScale(scaleData) {
      const customScales = JSON.parse(localStorage.getItem('customScales') || '[]');

      // Check if scale already exists (by exercise name)
      const existingIndex = customScales.findIndex(s => s.exercise === scaleData.exercise);

      if (existingIndex >= 0) {
        // Update existing scale
        customScales[existingIndex] = scaleData;
      } else {
        // Add new scale
        customScales.push(scaleData);
      }

      localStorage.setItem('customScales', JSON.stringify(customScales));
    }

    /**
     * Load custom scales from localStorage and add to catalog
     */
    function loadCustomScalesFromStorage() {
      const customScales = JSON.parse(localStorage.getItem('customScales') || '[]');

      // Remove existing custom scales from state.scales
      const customScaleIds = customScales.map(s => s.exercise);
      state.scales = state.scales.filter(s => !customScaleIds.includes(s.id));

      // Add custom scales to state.scales, using their actual category
      customScales.forEach(scaleData => {
        state.scales.push({
          id: scaleData.exercise,
          name: scaleData.scale_type || scaleData.exercise,
          category: scaleData.properties?.category || 'scales',
          data: scaleData
        });
      });

      // Refresh the dropdown
      populateScaleSelect();
    }

    /**
     * Delete a custom scale
     */
    function deleteCustomScale(scaleId) {
      const customScales = JSON.parse(localStorage.getItem('customScales') || '[]');
      const filtered = customScales.filter(s => s.exercise !== scaleId);
      localStorage.setItem('customScales', JSON.stringify(filtered));

      // Reload catalog
      loadCustomScalesFromStorage();
    }

    // Event listeners
    rootSelect.addEventListener('change', updateDisplay);

    fingeringPatternSelect.addEventListener('change', (e) => {
      state.selectedFingeringPattern = e.target.value;
      drawFretboard();
    });

    // Chord explorer event listeners
    document.getElementById('clearChordBtn').addEventListener('click', clearChordSelection);

    // Custom dropdown event listeners
    scaleSelectButton.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleDropdown();
    });

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (state.dropdownOpen && !scaleSelectButton.contains(e.target) && !scaleSelectDropdown.contains(e.target)) {
        closeDropdown();
      }
    });

    // Keyboard navigation for dropdown button
    scaleSelectButton.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        toggleDropdown();
      } else if (e.key === 'Escape') {
        closeDropdown();
      }
    });

    // Pattern search filter
    document.getElementById('patternSearch').addEventListener('input', (e) => {
      populateScaleSelect(e.target.value);

      // Auto-open dropdown when typing
      if (e.target.value && !state.dropdownOpen) {
        openDropdown();
      }
    });

    document.getElementById('playButton').addEventListener('click', playScale);

    document.getElementById('exportButton').addEventListener('click', exportScale);

    document.getElementById('importButton').addEventListener('click', () => {
      document.getElementById('importFileInput').click();
    });

    document.getElementById('importFileInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) {
        importScale(file);
        // Reset the input so the same file can be imported again
        e.target.value = '';
      }
    });

    document.getElementById('instrumentSelect').addEventListener('change', (e) => {
      initAudio(e.target.value);
    });

    // Metronome event listeners
    document.getElementById('metronomeToggle').addEventListener('click', async () => {
      await Tone.start();

      state.metronomeEnabled = !state.metronomeEnabled;
      const toggleBtn = document.getElementById('metronomeToggle');

      if (state.metronomeEnabled) {
        startMetronome();
        toggleBtn.textContent = 'On';
        toggleBtn.classList.add('active');
      } else {
        stopMetronome();
        toggleBtn.textContent = 'Off';
        toggleBtn.classList.remove('active');
      }
    });

    document.getElementById('metronomeBpm').addEventListener('change', (e) => {
      const newBpm = parseInt(e.target.value);
      if (newBpm >= 30 && newBpm <= 240) {
        state.metronomeBpm = newBpm;
        if (state.metronomeEnabled) {
          Tone.Transport.bpm.value = newBpm;
        }
      }
    });

    document.getElementById('metronomeSound').addEventListener('change', (e) => {
      state.metronomeSound = e.target.value;
      const wasEnabled = state.metronomeEnabled;

      if (wasEnabled) {
        stopMetronome();
      }

      initMetronome(state.metronomeSound);

      if (wasEnabled) {
        startMetronome();
      }
    });

    document.getElementById('metronomeBpmUp').addEventListener('click', () => {
      const currentBpm = state.metronomeBpm;
      const newBpm = Math.min(240, currentBpm + 1);
      state.metronomeBpm = newBpm;
      document.getElementById('metronomeBpm').value = newBpm;
      if (state.metronomeEnabled) {
        Tone.Transport.bpm.value = newBpm;
      }
    });

    document.getElementById('metronomeBpmDown').addEventListener('click', () => {
      const currentBpm = state.metronomeBpm;
      const newBpm = Math.max(30, currentBpm - 1);
      state.metronomeBpm = newBpm;
      document.getElementById('metronomeBpm').value = newBpm;
      if (state.metronomeEnabled) {
        Tone.Transport.bpm.value = newBpm;
      }
    });

    document.getElementById('fretRangeMinus').addEventListener('click', () => {
      state.fretMax = Math.max(5, state.fretMax - 6);
      document.getElementById('fretRangeDisplay').textContent = `${state.fretMin}-${state.fretMax}`;
      drawFretboard();
    });

    document.getElementById('fretRangePlus').addEventListener('click', () => {
      state.fretMax = Math.min(24, state.fretMax + 6);
      document.getElementById('fretRangeDisplay').textContent = `${state.fretMin}-${state.fretMax}`;
      drawFretboard();
    });

    document.querySelectorAll('[data-span]').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('[data-span]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        state.handSpan = parseInt(btn.dataset.span);
        drawFretboard();
      });
    });

    document.getElementById('toggleDisplay').addEventListener('click', (e) => {
      state.showDegrees = !state.showDegrees;
      e.currentTarget.textContent = state.showDegrees ? '#' : '‚ô™';
      e.currentTarget.title = state.showDegrees ? 'Showing degrees (click for notes)' : 'Showing notes (click for degrees)';
      drawFretboard();
    });

    document.getElementById('enharmonicToggle').addEventListener('click', (e) => {
      state.enharmonicPreference = state.enharmonicPreference === 'sharps' ? 'flats' : 'sharps';
      // Update button to show current preference
      e.currentTarget.textContent = state.enharmonicPreference === 'sharps' ? '‚ôØ' : '‚ô≠';
      e.currentTarget.title = state.enharmonicPreference === 'sharps' ? 'Showing sharps (click for flats)' : 'Showing flats (click for sharps)';
      populateRootSelect();
      updateDisplay(); // Recalculate scale with new enharmonic preference
    });

    document.getElementById('zoomIn').addEventListener('click', () => {
      state.zoom = Math.min(state.zoom * 1.2, 3.0);
      drawFretboard();
    });

    document.getElementById('zoomOut').addEventListener('click', () => {
      state.zoom = Math.max(state.zoom / 1.2, 0.5);
      drawFretboard();
    });

    document.getElementById('resetZoom').addEventListener('click', () => {
      state.zoom = 1.0;
      drawFretboard();
    });

    document.querySelectorAll('[data-markers]').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('[data-markers]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        state.markerStyle = btn.dataset.markers;
        drawFretboard();
      });
    });

    document.getElementById('viewModeToggle').addEventListener('click', () => {
      state.viewMode = state.viewMode === 'fretboard' ? 'position' : 'fretboard';
      document.getElementById('viewModeIcon').textContent = state.viewMode === 'fretboard' ? 'üéº' : 'üé∏';
      drawFretboard(); // Redraw with new view mode
    });

    document.getElementById('themeToggle').addEventListener('click', () => {
      state.theme = state.theme === 'dark' ? 'light' : 'dark';
      renderProgressions(); // Re-render progressions with new theme
      applyTheme();
    });

    // Canvas drag functionality
    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      const margin = 60;
      const width = canvas.width;
      const height = canvas.height;
      const fretCount = state.fretMax - state.fretMin;
      const fretSpacing = (width - 2 * margin) / fretCount;

      const practiceStart = state.practicePositionStart;
      const practiceEnd = practiceStart + state.handSpan - 1;

      if (practiceStart >= state.fretMin && practiceStart <= state.fretMax) {
        const x1 = margin + (practiceStart - state.fretMin) * fretSpacing;
        const x2 = margin + (Math.min(practiceEnd, state.fretMax) - state.fretMin + 1) * fretSpacing;

        if (mouseX >= x1 && mouseX <= x2 && mouseY >= margin - 10 && mouseY <= height - margin + 10) {
          state.isDragging = true;
          state.dragStartX = mouseX;
          state.dragStartFret = state.practicePositionStart;
          canvas.style.cursor = 'grabbing';
          e.preventDefault();
        }
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      const margin = 60;
      const width = canvas.width;
      const height = canvas.height;
      const fretCount = state.fretMax - state.fretMin;
      const fretSpacing = (width - 2 * margin) / fretCount;

      if (state.isDragging) {
        const deltaX = mouseX - state.dragStartX;
        const fretsDelta = Math.round(deltaX / fretSpacing);
        const newFret = Math.max(0, Math.min(24 - state.handSpan, state.dragStartFret + fretsDelta));

        if (newFret !== state.practicePositionStart) {
          state.practicePositionStart = newFret;
          drawFretboard();
        }
      } else {
        const practiceStart = state.practicePositionStart;
        const practiceEnd = practiceStart + state.handSpan - 1;

        if (practiceStart >= state.fretMin && practiceStart <= state.fretMax) {
          const x1 = margin + (practiceStart - state.fretMin) * fretSpacing;
          const x2 = margin + (Math.min(practiceEnd, state.fretMax) - state.fretMin + 1) * fretSpacing;

          if (mouseX >= x1 && mouseX <= x2 && mouseY >= margin - 10 && mouseY <= height - margin + 10) {
            canvas.style.cursor = 'grab';
          } else {
            canvas.style.cursor = 'default';
          }
        } else {
          canvas.style.cursor = 'default';
        }
      }
    });

    canvas.addEventListener('mouseup', () => {
      if (state.isDragging) {
        state.isDragging = false;
        canvas.style.cursor = 'grab';
      }
    });

    canvas.addEventListener('mouseleave', () => {
      if (state.isDragging) {
        state.isDragging = false;
        canvas.style.cursor = 'default';
      }
    });

    // Touch support for iOS/Android mobile
    canvas.addEventListener('touchstart', (e) => {
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];

      // Convert from display coordinates to canvas coordinates
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const touchX = (touch.clientX - rect.left) * scaleX;
      const touchY = (touch.clientY - rect.top) * scaleY;

      const margin = 60;
      const width = canvas.width;
      const height = canvas.height;
      const fretCount = state.fretMax - state.fretMin;
      const fretSpacing = (width - 2 * margin) / fretCount;

      const practiceStart = state.practicePositionStart;
      const practiceEnd = practiceStart + state.handSpan - 1;

      if (practiceStart >= state.fretMin && practiceStart <= state.fretMax) {
        const x1 = margin + (practiceStart - state.fretMin) * fretSpacing;
        const x2 = margin + (Math.min(practiceEnd, state.fretMax) - state.fretMin + 1) * fretSpacing;

        // More generous vertical hit area for touch (¬±30px in canvas space)
        if (touchX >= x1 && touchX <= x2 && touchY >= margin - 30 && touchY <= height - margin + 30) {
          state.isDragging = true;
          state.dragStartX = touchX;
          state.dragStartFret = state.practicePositionStart;
          e.preventDefault();
        }
      }
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      if (!state.isDragging) return;

      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];

      // Convert from display coordinates to canvas coordinates
      const scaleX = canvas.width / rect.width;
      const touchX = (touch.clientX - rect.left) * scaleX;

      const margin = 60;
      const width = canvas.width;
      const fretCount = state.fretMax - state.fretMin;
      const fretSpacing = (width - 2 * margin) / fretCount;

      const deltaX = touchX - state.dragStartX;
      const fretsDelta = Math.round(deltaX / fretSpacing);
      const newFret = Math.max(0, Math.min(24 - state.handSpan, state.dragStartFret + fretsDelta));

      if (newFret !== state.practicePositionStart) {
        state.practicePositionStart = newFret;
        drawFretboard();
      }

      e.preventDefault();
    }, { passive: false });

    canvas.addEventListener('touchend', () => {
      if (state.isDragging) {
        state.isDragging = false;
      }
    });

    canvas.addEventListener('touchcancel', () => {
      if (state.isDragging) {
        state.isDragging = false;
      }
    });

    /**
     * Create an SVG chord diagram
     */
    function createChordDiagram(chordData, root, themeName = 'dark') {
      const theme = themes[themeName];
      const voicing = chordData.properties.voicing;
      const chordName = chordData.chord_name || 'Chord';
      const expectedChordTones = chordData.properties.chord_tones || [];

      // Validate voicing notes match expected chord tones
      const invalidNotes = [];
      Object.entries(voicing).forEach(([stringKey, v]) => {
        if (v !== 'mute' && typeof v === 'object') {
          const note = v.note;
          const normalizedNote = note.replace('b', 'flat').replace('#', 'sharp');
          const noteIsValid = expectedChordTones.some(tone => {
            const normalizedTone = tone.replace('b', 'flat').replace('#', 'sharp');
            return normalizedNote === normalizedTone || normalizedNote.replace('flat', 'b').replace('sharp', '#') === normalizedTone;
          });
          if (!noteIsValid) {
            invalidNotes.push(`String ${stringKey}: ${note} (expected one of ${expectedChordTones.join(', ')})`);
          }
        }
      });

      if (invalidNotes.length > 0) {
        console.warn(`‚ö†Ô∏è Invalid notes in ${chordName} voicing:`, invalidNotes);
      }

      // Find fret range for the diagram and check for open strings
      let minFret = 20, maxFret = 0;
      let hasOpenStrings = false;
      Object.values(voicing).forEach(v => {
        if (v !== 'mute') {
          if (v.fret === '0') {
            hasOpenStrings = true;
          } else {
            const fret = parseInt(v.fret);
            minFret = Math.min(minFret, fret);
            maxFret = Math.max(maxFret, fret);
          }
        }
      });

      // Determine if this is an open position chord (has open strings or starts at fret 0-1)
      const isOpenPosition = hasOpenStrings || minFret <= 1;
      const startFret = isOpenPosition ? 0 : minFret;
      const numFrets = isOpenPosition ? 4 : Math.max(4, maxFret - startFret + 1);

      const width = 100;
      const height = 120;
      const margin = 15;
      const stringSpacing = (width - 2 * margin) / 5;
      const fretHeight = (height - 2 * margin) / numFrets;

      let svg = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">`;

      // Position indicator (always show for non-open position chords)
      if (!isOpenPosition) {
        svg += `<text x="12" y="${margin + fretHeight * 0.5 + 3}" font-family="Arial, sans-serif" font-size="13" font-weight="bold" fill="${theme.textPrimary}" text-anchor="end">${startFret}</text>`;
      }

      // Draw strings (vertical lines)
      for (let i = 0; i < 6; i++) {
        const x = margin + i * stringSpacing;
        svg += `<line x1="${x}" y1="${margin}" x2="${x}" y2="${margin + numFrets * fretHeight}" stroke="${theme.stringColor}" stroke-width="1.5"/>`;
      }

      // Draw frets (horizontal lines)
      for (let i = 0; i <= numFrets; i++) {
        const y = margin + i * fretHeight;
        const strokeWidth = (i === 0 && startFret === 0) ? 4 : 1.5;
        svg += `<line x1="${margin}" y1="${y}" x2="${margin + 5 * stringSpacing}" y2="${y}" stroke="${theme.fretColor}" stroke-width="${strokeWidth}"/>`;
      }

      // Draw notes/markers
      Object.keys(voicing).forEach(stringKey => {
        const stringNum = parseInt(stringKey);
        const stringIndex = 6 - stringNum;
        const x = margin + stringIndex * stringSpacing;
        const voicingData = voicing[stringKey];

        if (voicingData === 'mute') {
          // X for muted string
          svg += `<text x="${x}" y="${margin - 4}" font-family="sans-serif" font-size="14" font-weight="bold" fill="#d64545" text-anchor="middle">√ó</text>`;
        } else if (voicingData.fret === '0') {
          // O for open string
          svg += `<circle cx="${x}" cy="${margin - 8}" r="5" fill="none" stroke="${theme.noteColor}" stroke-width="2"/>`;
        } else {
          // Filled circle for fretted note
          const fret = parseInt(voicingData.fret);
          // For open position chords, fret lines start at 0 (nut), so fret 1 is between line 0 and 1
          // For non-open position, fret lines start at startFret, so startFret is between line 0 and 1
          const fretPosition = isOpenPosition ? fret - 1 : fret - startFret;
          const y = margin + (fretPosition + 0.5) * fretHeight;
          const isRoot = voicingData.note === root;
          const fill = isRoot ? theme.noteColor : theme.textSecondary;
          const fingerColor = themeName === 'dark' ? '#14141f' : '#14141f';
          svg += `<circle cx="${x}" cy="${y}" r="6" fill="${fill}"/>`;

          // Finger number
          if (voicingData.finger > 0) {
            svg += `<text x="${x}" y="${y + 4.5}" font-family="Arial, sans-serif" font-size="14" font-weight="bold" fill="${fingerColor}" text-anchor="middle">${voicingData.finger}</text>`;
          }
        }
      });

      svg += `</svg>`;
      return svg;
    }

    /**
     * Display a progression with chord diagrams arranged in rows (staves)
     */
    async function displayProgressionWithDiagrams(prog, scaleRoot, container) {
      const theme = themes[state.theme];

      const progItem = document.createElement('div');
      progItem.className = 'progression-item';
      progItem.style.cssText = `display: flex; flex-direction: column; gap: 0.75rem; padding: 0.75rem; background: ${theme.cardBg}; border-radius: 8px; border: 1px solid ${theme.cardBorder};`;

      // Header with progression name and description
      const progHeader = document.createElement('div');
      progHeader.style.cssText = 'display: flex; align-items: center; gap: 0.5rem;';

      const progIcon = document.createElement('span');
      progIcon.textContent = 'üéµ';
      progIcon.style.fontSize = '1rem';

      const progName = document.createElement('span');
      progName.textContent = prog.name;
      progName.style.cssText = `font-size: 0.875rem; font-weight: 600; color: ${theme.textSecondary};`;

      progHeader.appendChild(progIcon);
      progHeader.appendChild(progName);

      const progDesc = document.createElement('div');
      progDesc.textContent = prog.description;
      progDesc.style.cssText = `font-size: 0.75rem; color: ${theme.textMuted}; margin-left: 1.5rem;`;

      progItem.appendChild(progHeader);
      progItem.appendChild(progDesc);

      // Parse chord symbols from progression string
      // Example: "||: Cmaj7 | Fmaj7 | G7 | G7 :||" or "||: Am7 | Am7 | Dm7 | Dm7 :||"
      const chordPattern = /([A-G][#b]?(?:maj7|maj9|maj13|m7b5|m7|m9|m13|7|9|13|maj|min|dim|aug|m)?)/g;
      const matches = prog.progression.match(chordPattern) || [];

      if (matches.length === 0) {
        // Fallback to text display if no chords found
        const progChords = document.createElement('div');
        progChords.textContent = prog.progression;
        progChords.style.cssText = `font-size: 0.813rem; color: ${theme.noteColor}; font-family: monospace; margin-left: 1.5rem;`;
        progItem.appendChild(progChords);
        container.appendChild(progItem);
        return;
      }

      // Get unique chord symbols to load
      const uniqueChords = [...new Set(matches)];

      // Load chord data for all unique chords
      const chordDataMap = {};
      await Promise.all(uniqueChords.map(async (chordSymbol) => {
        const chordData = await loadSingleChordDiagram(chordSymbol);
        if (chordData) {
          chordDataMap[chordSymbol] = chordData;
        }
      }));

      // Create diagram display area with rows (staves)
      const diagramsContainer = document.createElement('div');
      diagramsContainer.style.cssText = 'display: flex; flex-direction: column; gap: 1rem; margin-left: 1.5rem;';

      // Check if progression has repeat markers
      const hasRepeat = prog.progression.includes('||:') || prog.progression.includes(':||');

      // Create a row for chord diagrams
      const row = document.createElement('div');
      row.style.cssText = 'display: flex; flex-wrap: wrap; gap: 1rem; align-items: flex-start;';

      // Add opening repeat sign if present
      if (hasRepeat) {
        const repeatStart = document.createElement('div');
        repeatStart.style.cssText = `display: flex; align-items: center; font-size: 2rem; color: ${theme.noteColor}; font-weight: bold; height: 120px;`;
        repeatStart.textContent = 'ùÑÜ';
        row.appendChild(repeatStart);
      }

      // Add chord diagrams
      matches.forEach((chordSymbol, index) => {
        const chordData = chordDataMap[chordSymbol];

        const chordWrapper = document.createElement('div');
        chordWrapper.style.cssText = 'display: flex; flex-direction: column; align-items: center; gap: 0.25rem;';

        // Chord name above diagram
        const chordLabel = document.createElement('div');
        chordLabel.textContent = chordSymbol;
        chordLabel.style.cssText = `font-size: 0.75rem; font-weight: 600; color: ${theme.textSecondary};`;
        chordWrapper.appendChild(chordLabel);

        if (chordData) {
          // Extract root note from chord symbol
          const chordRoot = chordSymbol.match(/^[A-G][#b]?/)[0];
          const diagram = createChordDiagram(chordData, chordRoot, state.theme);
          const diagramDiv = document.createElement('div');
          diagramDiv.innerHTML = diagram;
          chordWrapper.appendChild(diagramDiv);
        } else {
          // Show placeholder if chord data not found
          const placeholder = document.createElement('div');
          placeholder.style.cssText = `width: 100px; height: 120px; display: flex; align-items: center; justify-content: center; background: ${theme.controlBg}; border-radius: 4px; border: 1px dashed ${theme.cardBorder}; color: ${theme.textMuted}; font-size: 0.75rem; text-align: center;`;
          placeholder.textContent = 'N/A';
          chordWrapper.appendChild(placeholder);
        }

        row.appendChild(chordWrapper);

        // Add bar line after every 4 chords (except at the end)
        if ((index + 1) % 4 === 0 && index < matches.length - 1) {
          const barLine = document.createElement('div');
          barLine.style.cssText = `width: 2px; height: 120px; background: ${theme.fretColor}; margin: 0 0.5rem;`;
          row.appendChild(barLine);
        }
      });

      // Add closing repeat sign if present
      if (hasRepeat) {
        const repeatEnd = document.createElement('div');
        repeatEnd.style.cssText = `display: flex; align-items: center; font-size: 2rem; color: ${theme.noteColor}; font-weight: bold; height: 120px;`;
        repeatEnd.textContent = 'ùÑá';
        row.appendChild(repeatEnd);
      }

      diagramsContainer.appendChild(row);
      progItem.appendChild(diagramsContainer);
      container.appendChild(progItem);
    }

    /**
     * Load a single chord diagram (first position below fret 12)
     */
    async function loadSingleChordDiagram(chordSymbol) {
      // Extract root note and chord type
      const chordRoot = chordSymbol.match(/^[A-G][#b]?/)[0];
      const chordType = chordSymbol.replace(chordRoot, '');

      // Map chord type to file prefix and number of positions
      const chordFileMap = {
        'maj7': { prefix: 'maj7', positions: 6 },
        'm7': { prefix: 'min7', positions: 6 },
        '7': { prefix: '7', positions: 6 },
        'maj9': { prefix: 'maj9', positions: 4 },
        'm9': { prefix: 'min9', positions: 4 },
        '9': { prefix: '9', positions: 4 },
        'maj13': { prefix: 'maj13', positions: 4 },
        'm13': { prefix: 'min13', positions: 4 },
        '13': { prefix: '13', positions: 4 },
        'm': { prefix: 'min', positions: 4 },
        '': { prefix: 'maj', positions: 4 },
        'dim': { prefix: 'dim', positions: 4 },
        'm7b5': { prefix: 'm7b5', positions: 4 },
        'aug': { prefix: 'aug', positions: 6 }
      };

      const chordInfo = chordFileMap[chordType] || { prefix: chordType, positions: 6 };
      const filePrefix = chordInfo.prefix;
      const numPositions = chordInfo.positions;
      const MAX_FRET = 12;

      // Try positions 1 through numPositions, return first one below fret 12
      for (let pos = 1; pos <= numPositions; pos++) {
        try {
          const response = await fetch(`chords/${chordRoot.toLowerCase()}${filePrefix}_pos${pos}.json`);
          if (response.ok) {
            const data = await response.json();
            const chord = data.Item;
            const startingFret = parseInt(chord.starting_fret);

            // Return first chord that starts at or below fret 12
            if (startingFret <= MAX_FRET) {
              return chord;
            }
          }
        } catch (err) {
          // Continue to next position
        }
      }

      console.warn(`Could not find chord diagram for ${chordSymbol} below fret ${MAX_FRET}`);
      return null;
    }

    /**
     * Load and display chord voicings
     */
    async function loadChordVoicings(chordRoot, chordSymbol) {
      const container = document.getElementById('chordDiagramsContainer');
      const section = document.getElementById('chordVoicingsSection');

      container.innerHTML = '<div style="font-size: 0.875rem;">Loading chord voicings...</div>';
      section.style.display = 'block';
      applyTheme(); // Apply theme after showing section

      // Extract chord type from symbol (remove root note)
      const chordType = chordSymbol.replace(chordRoot, '');

      // Map chord type suffixes to file prefixes and number of positions
      const chordFileMap = {
        'maj7': { prefix: 'maj7', positions: 6 },
        'm7': { prefix: 'min7', positions: 6 },
        '7': { prefix: '7', positions: 6 },
        'maj9': { prefix: 'maj9', positions: 4 },
        'm9': { prefix: 'min9', positions: 4 },
        '9': { prefix: '9', positions: 4 },
        'maj13': { prefix: 'maj13', positions: 4 },
        'm13': { prefix: 'min13', positions: 4 },
        '13': { prefix: '13', positions: 4 },
        'm': { prefix: 'min', positions: 4 },
        '': { prefix: 'maj', positions: 4 },  // Plain root letter = major triad
        'dim': { prefix: 'dim', positions: 4 },
        'm7b5': { prefix: 'm7b5', positions: 4 },
        'aug': { prefix: 'aug', positions: 6 }
      };

      const chordInfo = chordFileMap[chordType] || { prefix: chordType, positions: 6 };
      const filePrefix = chordInfo.prefix;
      const numPositions = chordInfo.positions;

      const chordFiles = [];
      for (let i = 1; i <= numPositions; i++) {
        chordFiles.push(`${chordRoot.toLowerCase()}${filePrefix}_pos${i}`);
      }

      try {
        const chordPromises = chordFiles.map(async (filename) => {
          try {
            const response = await fetch(`chords/${filename}.json`);
            const data = await response.json();
            return data.Item;
          } catch (err) {
            // Silently ignore missing files
            return null;
          }
        });

        let chords = (await Promise.all(chordPromises)).filter(c => c !== null);

        // Filter out high-fret voicings (above fret 14) and remove duplicates
        const MAX_FRET = 14;
        const seenVoicings = new Set();
        chords = chords.filter(chord => {
          const startingFret = parseInt(chord.starting_fret);

          // Skip if too high on the neck
          if (startingFret > MAX_FRET) {
            return false;
          }

          // Create a unique signature for this voicing based on fret positions
          const voicing = chord.properties.voicing;
          const signature = Object.keys(voicing).sort().map(stringKey => {
            const v = voicing[stringKey];
            if (v === 'mute') return 'x';
            return v.fret;
          }).join('-');

          // Skip if we've already seen this exact voicing (duplicate)
          if (seenVoicings.has(signature)) {
            return false;
          }

          seenVoicings.add(signature);
          return true;
        });

        if (chords.length === 0) {
          container.innerHTML = '<div style="font-size: 0.875rem;">No chord voicings available yet. Use chord_input_tool.py to add them!</div>';
          applyTheme(); // Apply theme colors to the message
          return;
        }

        container.innerHTML = '';
        chords.forEach(chord => {
          const diagram = createChordDiagram(chord, chordRoot, state.theme);
          const wrapper = document.createElement('div');
          wrapper.innerHTML = diagram;
          container.appendChild(wrapper);
        });
      } catch (err) {
        console.error('Error loading chord voicings:', err);
        container.innerHTML = '<div style="color: #d64545; font-size: 0.875rem;">Error loading chord voicings</div>';
      }
    }

    // Close voicings section handler
    document.getElementById('closeVoicingsBtn').addEventListener('click', () => {
      document.getElementById('chordVoicingsSection').style.display = 'none';
    });

    // Initialize
    loadScaleCatalog().then(() => {
      applyTheme();
    });
  </script>
</body>
</html>
